XML (_eXtensible Markup Language_) deriva da SGML (_Standard Generalized Markup Language_). Sia XML che SGML permettono di definire linguaggi di markup specifici per diversi ambiti, come la finanza o la matematica. Un esempio di linguaggio derivato da SGML è HTML.

Rispetto a SGML, XML è più semplice da utilizzare ed è stato progettato per definire linguaggi di markup destinati all’uso su Internet. Sebbene possa sembrare un concetto astratto, XML di per sé non _fa_ nulla.

Inizialmente, XML è nato come un formato per lo scambio di dati ed è spesso utilizzato per separare i dati dalla loro presentazione. In questa analisi, ci concentreremo sulle sue capacità di memorizzazione e ricerca dei dati, tralasciando i dettagli più approfonditi per focalizzarci sugli aspetti rilevanti per la gestione dei dati.

**Esempio di documento XML**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<?tex doctype[report] ?>
<doc isbn="2-266-04744-2">
  <!-- editor is missing! -->
  <author>T. Harris</author>
  <title xml:lang="en">The silence of the lambs</title>
  <title xml:lang="fr">Le silence des agneaux</title>
  <comment>
    A book full of <i>suspance</i>.
  </comment>
  <price currency="euro">7</price>
</doc>
```

In XML, i dati vengono rappresentati attraverso markup e caratteri testuali, permettendo una gestione flessibile e strutturata delle informazioni.

## Prologo

Il prologo di un documento XML contiene informazioni utili per la sua interpretazione. In particolare, può includere:

- Una dichiarazione che specifica che il documento è in formato XML (opzionale).
- Una grammatica (_DOCTYPE_) che permette di validare il contenuto del documento (opzionale).
- Commenti e informazioni destinate alle applicazioni software che utilizzeranno il documento, sotto forma di _Processing Instructions_ (PI), che possono essere presenti in numero variabile.

**Esempio di prologo in un documento XML**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<?tex doctype[report] ?>
```

Questa parte del documento non contiene dati veri e propri ma fornisce istruzioni che possono essere utilizzate dai parser XML per interpretare correttamente la struttura e il contenuto.
## Corpo del documento

Il corpo di un documento XML è costituito da un unico elemento radice (_root element_), che a sua volta può contenere altri elementi annidati, oltre a eventuali commenti.

Un documento XML ben formato deve rispettare alcune regole fondamentali:

- Deve avere un unico elemento radice.
- Gli elementi devono essere correttamente annidati e chiusi.
- I nomi degli elementi fanno distinzione tra maiuscole e minuscole.
- I valori degli attributi devono essere racchiusi tra virgolette.

**Esempio di corpo di un documento XML ben formato**

```xml
<doc isbn="2-266-04744-2">
  <!-- editor is missing! -->
  <author>T. Harris</author>
  <title xml:lang="en">The silence of the lambs</title>
  <title xml:lang="fr">Le silence des agneaux</title>
  <comment>
    A book full of <i>suspance</i>.
  </comment>
  <price currency="euro">7</price>
</doc>
```

## Elementi in XML

Un elemento XML può avere due forme principali:

1. **Forma estesa**: contiene un'apertura, del contenuto e una chiusura esplicita.
    
    ```xml
    <book isbn="978-3-16-148410-0">
      <title>The Art of War</title>
      <author>Sun Tzu</author>
    </book>
    ```
    
2. **Forma abbreviata (auto-chiusa)**: viene utilizzata quando un elemento non ha contenuto interno.
    
    ```xml
    <img src="cover.jpg" alt="Book Cover" />
    ```
    

Nella forma estesa, l'elemento può contenere altri elementi annidati, testo e attributi. Nella forma auto-chiusa, invece, l'elemento si chiude direttamente, evitando la necessità di un tag di chiusura separato.

## Elementi e attributi ben formati

Ogni elemento deve essere contenuto tra un tag di apertura e un tag di chiusura o può avere una forma breve.

```xml
<?xml version="1.0"?>
<?tex doctype[report] ?>
<doc isbn="2-266-04744-2">
  <title xml:lang="en">
    The silence of the lambs
  </title>
  <price euro="7"/>
</doc>
```


**Nota.** I tag ``<BR>`` e simili sono da evitare, perché vengono aperti ma mai chiusi!

I nomi degli elementi e degli attributi fanno distinzione tra maiuscole e minuscole. Gli elementi devono essere nidificati correttamente e deve esserci un solo elemento che contiene tutti gli altri elementi.

I valori degli attributi devono essere racchiusi tra virgolette singole o doppie.

Un elemento non può avere più di un attributo con lo stesso nome.

**Esempio (errato)**

```xml
<book author=“Doe” author=“Blake”/>
```

**Esempio corretto per rappresentare più autori**

```xml
<book>
  <author>Doe</author>
  <author>Verdi</author>
</book>
```


All'inizio di un documento XML può essere presente una dichiarazione del tipo di documento. Questa dichiarazione contiene una grammatica, chiamata Document Type Definition (DTD), con il doppio scopo di vincolare e completare i documenti.

La DTD è composta da dichiarazioni di markup che definiscono cosa può e cosa non può essere scritto nel documento XML corrispondente.

Le DTD determinano quali elementi possono essere inclusi nel documento, come possono essere utilizzati, quali sono i valori predefiniti degli attributi degli elementi e altre restrizioni.

![[Pasted image 20250220121558.png]]

## Documenti validi e ben formati

Un documento XML è considerato valido se contiene una DTD e rispetta le regole definite al suo interno. Un documento può essere ben formato senza essere valido. Un esempio di documento ben formato ma non valido è il seguente:

```xml
<greetings>Hello, world!</greetings>
```

In questo caso, il documento segue la sintassi XML corretta, ma non contiene una DTD, quindi non può essere considerato valido. Un documento ben formato segue le regole sintattiche di XML, come la corretta nidificazione degli elementi, l’uso di attributi racchiusi tra virgolette e la presenza di un unico elemento radice. Un documento valido, oltre a rispettare queste regole, deve anche conformarsi alla grammatica definita dalla DTD.

Definiamo un tipo di documento, chiamato _greetings_ e che contiene un elemento `<greetings>`, il quale non può contenere altri elementi. Gli attributi di `<greetings>` vengono dichiarati, in questo caso solo l’attributo `id`.

Esempio di definizione interna della DTD:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE greetings [
  <!ELEMENT greetings (#PCDATA)>
  <!ATTLIST greetings
    id ID #REQUIRED>
]>
<greetings id="0001">Hello, world!</greetings>
```

Gli stessi vincoli possono essere definiti in un file esterno, ad esempio _hello.dtd_, e dichiarati nel documento XML nel modo seguente:

```xml
<?xml version="1.0"?>
<!DOCTYPE greetings SYSTEM "hello.dtd">
<greetings>Hello, world!</greetings>
```

In questo caso, il file _hello.dtd_ conterrà la definizione della struttura del documento, consentendo di separare la dichiarazione della grammatica dal contenuto XML.

![[Pasted image 20250220122749.png]]

## DTD e XML Schema

Una DTD impone vincoli a un documento XML, ma è possibile specificare restrizioni più complesse di quelle consentite da una DTD. Ad esempio, si possono definire chiavi importate, vincoli di unicità o domini per elementi e attributi, come avviene nei database SQL.

L'XML Schema consente di specificare questo tipo di vincoli ed è quindi un'alternativa alla DTD. A differenza delle DTD, i vincoli dell'XML Schema sono espressi direttamente in XML, rendendolo più leggibile e integrabile con altri documenti XML.

Gli XML Schema offrono diversi vantaggi rispetto alle DTD. Sono estensibili, permettono l'aggiunta di nuovi elementi senza dover riscrivere l'intera definizione, supportano i tipi di dati per garantire che i valori degli elementi e degli attributi siano conformi a determinati formati e offrono il supporto per i namespace, facilitando l'integrazione con documenti XML provenienti da diverse fonti.

La riga `xmlns:xsi="..."` indica al parser che il documento deve essere validato rispetto a uno schema (in particolare, la stringa rappresenta un identificatore univoco per quel file)

La riga `xsi:noNamespaceSchemaLocation="shiporder.xsd"` specifica la posizione dello schema, che in questo caso si trova nella stessa cartella del file _shiporder.xml_.

Esempio di documento XML che utilizza un XML Schema:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<shiporder orderid="889923"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:noNamespaceSchemaLocation="shiporder.xsd">
  
  <orderperson>John Smith</orderperson>
  
  <shipto>
    <name>Ola Nordmann</name>
    <address>Langgt 23</address>
    <city>4000 Stavanger</city>
    <country>Norway</country>
  </shipto>
  
  ...
</shiporder>
```

In questo esempio, il documento XML fa riferimento a uno schema definito nel file _shiporder.xsd_, che fornisce le regole per la validazione del contenuto. L'XML Schema consente di specificare i tipi di dati, la struttura e i vincoli sugli elementi e sugli attributi, garantendo una maggiore precisione rispetto a una DTD tradizionale.

![[Pasted image 20250220123031.png]]

XML non richiede necessariamente una DTD o un XML Schema. Quando si sperimenta con XML o si lavora con file di piccole dimensioni, creare una DTD potrebbe essere superfluo e una perdita di tempo.

Tuttavia, l'uso di DTD e XML Schema permette ai file XML di includere una descrizione della propria struttura. Questo facilita la definizione di standard condivisi tra gruppi indipendenti per lo scambio di dati, oltre a consentire la verifica delle informazioni ricevute dall'esterno.

Uno dei principali punti di forza degli XML Schema è il supporto per i tipi di dati. Questo rende più semplice descrivere il contenuto di un documento, definire restrizioni sui dati, validare la loro correttezza e convertirli tra diversi formati.

# JSON vs XML

JSON (JavaScript Object Notation) è basato sul linguaggio JavaScript, mentre XML (Extensible Markup Language) è derivato da SGML. JSON rappresenta oggetti, mentre XML è un linguaggio di markup che utilizza una struttura a tag per rappresentare i dati.

![[Pasted image 20250220124228.png]]
Una delle principali differenze è che JSON non supporta i namespace, mentre XML sì. JSON supporta gli array, mentre XML no. I file JSON sono generalmente più facili da leggere rispetto ai documenti XML, che risultano più complessi da interpretare.

JSON non utilizza tag di chiusura, mentre XML richiede sia un tag di apertura che uno di chiusura. Inoltre, XML supporta i commenti, mentre JSON no. Per quanto riguarda la codifica, JSON supporta solo UTF-8, mentre XML permette diversi tipi di codifica.

I tipi di dati validi in JSON includono stringhe, numeri, oggetti JSON, array, valori booleani e `null`.

## Uso proprio e improprio di XML

XML offre un'ampia libertà ai progettisti di documenti XML, permettendo loro di scegliere i tag e gli attributi da utilizzare e di decidere dove posizionare i dati. Tuttavia, quando XML viene utilizzato per memorizzare dati, è fondamentale prestare attenzione all'uso corretto degli elementi del modello di dati, inclusi elementi, attributi, contenuti e gerarchie.

Seguire linee guida precise aiuta a garantire la coerenza, la leggibilità e la corretta interpretazione dei dati. Un uso improprio degli elementi XML può portare a documenti difficili da gestire e comprendere. Nei prossimi passaggi verranno illustrate alcune linee guida essenziali per un corretto utilizzo di XML.

### 1 – Dati nel contenuto degli elementi

I dati devono essere memorizzati all'interno del contenuto degli elementi piuttosto che negli attributi. Ad esempio:

```xml
<book>
  <title>The Great Gatsby</title>
</book>
```

È preferibile rispetto a:

```xml
<book title="The Great Gatsby" />
```

Evitare di memorizzare informazioni strutturali negli attributi, poiché ciò limita la flessibilità del documento XML.

### 2 – Metadati in attributi o nomi di elementi

Quando un'informazione è un metadato, essa non deve apparire come contenuto dell'elemento. Ad esempio:

```xml
<book>
  <property>
    <name>title</name>
    <value>The Great Gatsby</value>
  </property>
</book>
```

In questo caso, _title_ è un metadato, quindi non deve essere trattato come contenuto generico dell'elemento.

### 3 – Uso (in)corretto delle gerarchie

Un utilizzo errato delle gerarchie può portare a documenti XML difficili da interpretare. Nell'esempio seguente, i due titoli e autori sono separati solo dall'ordine degli elementi, rendendo difficile capire a quale libro appartiene ciascun autore:

```xml
<db>
  <title>The Great Gatsby</title>
  <author>F Scott Fitzgerald</author>
  <title>For Whom the Bell Tolls</title>
  <author>Ernest Hemingway</author>
</db>
```

Per evitare ambiguità, è necessario raggruppare i titoli e gli autori all'interno di un elemento `<book>`.

### 4 – Uso corretto delle gerarchie

Un'organizzazione gerarchica corretta prevede che ogni libro sia racchiuso in un elemento `<book>`, garantendo chiarezza nella struttura:

```xml
<db>
  <book>
    <title>The Great Gatsby</title>
    <author>F Scott Fitzgerald</author>
  </book>
  <book>
    <title>For Whom the Bell Tolls</title>
    <author>Ernest Hemingway</author>
  </book>
</db>
```

Questa struttura migliora la leggibilità e la gestione dei dati. Per ulteriori esempi, si possono consultare le risorse di W3Schools:

- https://www.w3schools.com/xml/Books.xml
- https://www.w3schools.com/xml/cd_catalog.xml

## XML namespaces – conflitti di nomi

In XML, i nomi degli elementi sono definiti dallo sviluppatore. Questo può causare conflitti quando si combinano documenti XML provenienti da diverse applicazioni, poiché lo stesso nome di elemento può avere significati differenti.

Esempio di due frammenti XML separati:

```xml
<table>
  <tr>
    <td>Apples</td>
    <td>Bananas</td>
  </tr>
</table>
```

```xml
<table>
  <name>African Coffee Table</name>
  <width>80</width>
  <length>120</length>
</table>
```

Nel primo caso, l'elemento `<table>` trasporta informazioni su una tabella HTML, mentre nel secondo caso `<table>` rappresenta una tabella generica con attributi specifici. Se questi due frammenti venissero uniti nello stesso documento XML, si verificherebbe un conflitto di nomi, poiché entrambi contengono un elemento `<table>` con contenuti e significati differenti.

Per evitare questi conflitti, si utilizzano gli **XML Namespaces**, che permettono di distinguere elementi con lo stesso nome ma provenienti da contesti diversi. Definendo un namespace per ogni origine, si può garantire che ogni elemento sia interpretato correttamente senza ambiguità.

## Risoluzione dei conflitti di nomi con un prefisso

I conflitti di nomi in XML possono essere facilmente evitati utilizzando un prefisso per distinguere gli elementi provenienti da contesti diversi. Ad esempio:

```xml
<h:table>
  <h:tr>
    <h:td>Apples</h:td>
    <h:td>Bananas</h:td>
  </h:tr>
</h:table>

<f:table>
  <f:name>African Coffee Table</f:name>
  <f:width>80</f:width>
  <f:length>120</f:length>
</f:table>
```

In questo caso, il prefisso `h:` è utilizzato per identificare gli elementi relativi a una tabella HTML, mentre `f:` viene usato per gli elementi di una tabella generica di mobili.

## XML namespaces – L’attributo `xmlns`

Quando si utilizzano prefissi in XML, è necessario definire uno **spazio dei nomi (namespace)** per ciascun prefisso mediante l'attributo `xmlns` nel tag iniziale.

Esempio corretto con spazi dei nomi dichiarati:

```xml
<root>
  <h:table xmlns:h="http://www.w3.org/TR/html4/">
    <h:tr>
      <h:td>Apples</h:td>
      <h:td>Bananas</h:td>
    </h:tr>
  </h:table>

  <f:table xmlns:f="https://www.w3schools.com/furniture">
    <f:name>African Coffee Table</f:name>
    <f:width>80</f:width>
    <f:length>120</f:length>
  </f:table>
</root>
```

In questo esempio:

- Il namespace `h` (`http://www.w3.org/TR/html4/`) identifica elementi HTML.
- Il namespace `f` (`https://www.w3schools.com/furniture`) identifica elementi relativi ai mobili.

Grazie ai prefissi e agli spazi dei nomi, gli elementi appartenenti a diversi domini possono coesistere nello stesso documento XML senza generare ambiguità.