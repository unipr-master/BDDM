## Indici basati su hash

L'hashing mappa una chiave di ricerca direttamente all'ID di pagina ($PID$) della pagina contenente o della catena di overflow delle pagine. Gli indici basati su hash sono particolarmente adatti per la ricerca per uguaglianza, ma non supportano efficientemente la ricerca per intervalli. Analogamente agli indici basati sull'ordinamento, esistono tecniche di hashing statico e dinamico.

L'hashing statico è utilizzato per dati di dimensioni fisse e immutabili, come quelli presenti su un CD-ROM a sessione singola. L'hashing estensibile e l'hashing lineare, invece, sono adatti quando sia i dati che le loro dimensioni possono variare nel tempo. Come negli indici ad albero per la memoria secondaria, gli indici hash utilizzano blocchi per memorizzare i bucket.

## Hashing statico

L'hashing statico prevede l'uso di $N$ bucket e di una funzione di hash che mappa la chiave di ricerca in un intervallo compreso tra $0$ e $N-1$. Di seguito, utilizzeremo funzioni di hash $H_i$ che restituiscono i primi (o ultimi) $i$ bit della codifica binaria della chiave di ricerca.  

Se un record ha come chiave di ricerca $K$, allora memorizziamo il record nel bucket numerato $H(K)$.   Mostreremo le chiavi già codificate, come nell'esempio seguente, utilizzando il bit più significativo. In questo caso, $i = 1$, $N = 2^i = 2$, e ciascun bucket contiene un blocco.  

![[Pasted image 20250312111346.png|300]]

## Hashing statico: ricerca

La funzione di hash calcola l'indirizzo del bucket in cui si trova il record di dati con una determinata chiave di ricerca (se presente). Ad esempio, se la chiave di ricerca è $K_2 = 1100$, la funzione di hash determina l'indirizzo del bucket corrispondente.  

![[Pasted image 20250312114317.png|550]]

## Hashing statico: eliminazione

Catene lunghe di blocchi di overflow degradano le prestazioni. 

![[Pasted image 20250312111302.png|700]]

L'eliminazione delle chiavi può portare alla rimozione dei blocchi di overflow.  

## Efficienza degli indici di hashing statico

Idealmente, il numero di bucket è sufficiente affinché la maggior parte di essi rientri in un singolo blocco. In tal caso, la ricerca richiede un solo accesso al disco.  

Catene lunghe di blocchi di overflow provocano un rapido degrado delle prestazioni, poiché ogni blocco di overflow richiede almeno un accesso al disco.  

L'efficienza dipende da diversi fattori:  
- Il rapporto tra la dimensione dell'indice e i dati, ovvero il numero di bucket.  
- La distribuzione dei valori della chiave di ricerca rispetto alla funzione di hash.  

È importante mantenere il numero di blocchi per bucket il più basso possibile. La funzione di hash può essere modificata dinamicamente per adattare il numero di bucket alla dimensione del file di dati.  

Si possono utilizzare tecniche come l'hashing estendibile, che in caso di necessità consente di raddoppiare il numero di bucket, o l'hashing lineare, che permette l'aggiunta di un bucket. 

## Hashing estendibile

L'hashing estendibile introduce un livello di indirezione per i bucket. In particolare, utilizza una directory di puntatori ai blocchi. Questa directory può espandersi e la sua lunghezza è sempre una potenza di 2, definita come profondità globale. Quando la directory raddoppia di dimensione (passo di crescita), anche il numero di bucket raddoppia.  

Non è necessario che ogni bucket abbia un proprio blocco dati; alcuni bucket possono condividere lo stesso blocco. L'hashing estendibile non utilizza blocchi di overflow.  

La funzione di hash restituisce i primi $i$ bit più significativi della codifica binaria della chiave di ricerca. Ogni blocco ha una variabile che indica quanti bit vengono utilizzati per il suo indicizzamento, chiamata profondità locale.  


## Hashing estendibile: ricerca

![[Pasted image 20250312111548.png]]

## Hashing estendibile: passi per l'inserimento  

Per inserire un record con chiave di ricerca $K$, si prendono i primi $i$ bit della sequenza di bit $H_i(K)$ per identificare il bucket nella directory. Se c'è spazio nel blocco corrispondente, il record viene inserito.  

Se non c'è spazio, si presentano due possibilità a seconda del valore di $j$, che indica il numero di bit attualmente utilizzato per indicizzare il blocco coinvolto $B$.  

Se $j < i$, il blocco $B$ viene suddiviso in due (divisione a metà). I record presenti in $B$ vengono ridistribuiti tra i due nuovi blocchi in base al valore del loro bit $(j+1)$. Il valore di $j$ viene incrementato di 1 e la directory viene aggiornata con il puntatore al nuovo blocco.  

Se $j = i$, il valore di $i$ viene incrementato di 1 (raddoppio). La directory viene raddoppiata, in modo che un'entrata indicizzata dalla sequenza di bit $w$ di $i$ bit produca due nuove entrate, $w0$ e $w1$. Successivamente, si procede come nel caso precedente.  

## Hashing estendibile: osservazioni  

Poiché non ci sono blocchi di overflow, se la directory è contenuta interamente nella memoria principale, una ricerca di uguaglianza può essere risolta con uno o due accessi al disco.  

La suddivisione dei blocchi comporta solo una riorganizzazione minima, poiché i record di un singolo blocco vengono semplicemente ridistribuiti tra i due nuovi blocchi. Tuttavia, se la redistribuzione dopo una divisione è sfortunata, potrebbe essere necessario dividere nuovamente uno dei blocchi appena creati. Questo può accadere, ad esempio, quando i record iniziano con la stessa sequenza di bit.  

La crescita della directory avviene a scatti e, se la distribuzione dei valori hash è sbilanciata, la directory potrebbe crescere in modo eccessivo e non necessario. Inoltre, la crescita esponenziale della directory può rendere più complessa la sua gestione e il suo mantenimento nella memoria principale.  

## Hashing lineare  

L'hashing lineare elimina la necessità di una directory, ma gestisce comunque il problema delle lunghe catene di blocchi di overflow. Il numero di bucket cresce uno alla volta e l'uso di blocchi di overflow è consentito.  

L'aumento del numero di bucket avviene in modo lineare, in particolare quando viene creato un blocco di overflow o quando viene superata una determinata soglia. Questa soglia è rappresentata dal rapporto tra il numero di record e il numero di bucket ed è definita come fattore di carico. Seguiremo la politica di scegliere il numero di bucket $n$ in modo che non vi siano più di $(1.7 \cdot n)$ record nel file.  

La funzione di hash $H_i(K)$ restituisce i $i$ bit meno significativi della codifica binaria della chiave di ricerca.  

## Hashing lineare: ricerca  

Supponiamo di voler cercare un record utilizzando la chiave di ricerca $K_2 = 0101$.  


![[Pasted image 20250312114550.png]]

Sia $n$ il numero di bucket, con $2^{i-1} < n \leq 2^i$. Se la funzione di hash $H_i(K) = m$ e $m < n$, la chiave di ricerca si trova nel bucket $m$. Se invece $H_i(K) = m \geq n$, la chiave di ricerca si trova nel bucket $(m - 2^{i-1})$.  

## Hashing lineare: fasi di inserimento

Si considerino il numero di record $r$ e il numero di bucket $n$. Se il rapporto $r/n$ supera $1.7$, viene suddiviso un bucket e viene aggiunto il bucket $(n+1)$-esimo.

Utilizzando la funzione di hash $H_i$, tutti i bucket fino al $(2^i - 1)$-esimo vengono suddivisi seguendo un ordine predefinito e indipendentemente dal bucket che ha causato la divisione.

Se $n$ supera $2^i$, la funzione di hash viene aggiornata a $i+1$ e la suddivisione riprende dal primo bucket.

Se la funzione di hash $H_i(K) = m < n$, allora la chiave di ricerca può essere inserita nel $m$-esimo bucket. Se non c'è spazio nel bucket designato, viene creato un blocco di overflow.

Se la funzione di hash $H_i(K) = m \geq n$, allora la chiave di ricerca può essere inserita nel $(m - 2^{i-1})$-esimo bucket. Se non c'è spazio nel bucket designato, viene creato un blocco di overflow.

L'incremento del numero di record $r$ porta a un aggiornamento della struttura se il rapporto $r/n$ supera $1.7$. In tal caso:

1. Se $n = 2^i$, allora $i$ viene incrementato di $1$.
   - $n_2$ viene rappresentato come $a_1 a_2 ... a_i$ con $a_1 = 1$.
   - Il primo bit di $n$ viene cancellato e memorizzato in $m$:  $a_1 a_2 ... a_i \rightarrow 0 a_2 ... a_i$.
2. Viene aggiunto il $n$-esimo bucket.
3. Tutti i record dal blocco $m$ che hanno il bit $i$-esimo più a destra uguale a 1 vengono spostati nel $n$-esimo blocco.
4. Il valore di $n$ viene incrementato di $1$.

## Hashing lineare: inserimento
 
Si considera la ricerca utilizzando la chiave $K_2 = 0101$. Sia $n$ il numero di bucket, con $2^{i-1} < n \leq 2^i$. 

![[Pasted image 20250312135921.png]]

Se la funzione di hash $H_i(K) = m < n$, allora la chiave di ricerca si trova nel bucket $m$. Se invece $H_i(K) = m \geq n$, la chiave di ricerca si trova nel bucket $(m - 2^{i-1})$.


![[Pasted image 20250312135432.png]]



