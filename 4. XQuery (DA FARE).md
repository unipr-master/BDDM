XQuery è un linguaggio di interrogazione per dati espressi in XML, e può quindi essere utilizzato per accedere a documenti strutturati e semi-strutturati. È diventato una raccomandazione del W3C nel gennaio 2007. XQuery è un linguaggio case sensitive (come XML), copre l’ultima versione di XPath e presenta funzionalità simili a quelle di XSLT (eXtensible Stylesheet Language Transformations). Il linguaggio XQuery è un linguaggio tipato di espressioni (funzionale).

## Sequenze

A differenza di SQL, che opera su relazioni, XQuery opera su sequenze, che possono contenere valori atomici, come la stringa `"hello"` o l'intero `3`, oppure nodi. Un'espressione XQuery riceve zero (nel caso dei costruttori) o più sequenze e produce una sequenza.

Le principali caratteristiche delle sequenze sono le seguenti: le sequenze sono ordinate, quindi la sequenza $(1, 2)$ è diversa da $(2, 1)$. Le sequenze non sono annidate, quindi $((), 1, (2, 3))$ è equivalente a $(1, 2, 3)$. Non esiste differenza tra un elemento e una sequenza contenente lo stesso elemento: $(1)$ è uguale a $1$.

Per manipolare le sequenze, XQuery fornisce i seguenti operatori: la virgola `,` e l’operatore `to`. Esempi di sintassi alternative per definire la sequenza degli interi $1$, $2$ e $3$ sono:

$(1, 2, 3)$  
$(1, (), (2, 3))$  
$(1 \text{ to } 3)$  
$(1, 2 \text{ to } 3)$

Sono inoltre disponibili gli operatori `union` (anche nella forma equivalente `|`), `intersect` ed `except`. Alcuni esempi:

$(A) \text{ union } (A, B) \rightarrow (A, B)$  
$(A, B) \text{ intersect } (B, C) \rightarrow (B)$  
$(A, B) \text{ except } (B) \rightarrow (A)$

## Nodi

Oltre ai valori atomici, una sequenza può contenere nodi. I documenti e frammenti XML sono rappresentati come alberi, i cui nodi possono essere di tipo: `document`, `element`, `attribute`, `namespace`, `text`, `comment` e `processing-instruction`.

I nodi di tipo `namespace`, come `<xmlns:xsi>`, non sono rappresentati nel modello di dati di XQuery, quindi non vengono considerati. Allo stesso modo, non vengono trattati i commenti e le istruzioni di elaborazione (`processing instructions`), che non sono (o non dovrebbero essere) utilizzati per memorizzare dati.

Il valore testuale (string value) di un nodo documento è pari al contenuto concatenato di tutti i suoi nodi discendenti di tipo `text`, nell’ordine in cui compaiono nel documento.

I nodi di tipo `attribute` non sono ordinati: se vengono estratti tramite una query in XQuery, l’ordine non corrisponde necessariamente a quello in cui sono stati definiti nel documento XML di origine. Tuttavia, una volta estratti, vengono inseriti in una sequenza, della quale mantengono l’ordine.

Due nodi di tipo `text` non possono essere adiacenti. Ad esempio, un elemento `<name>John Doe</name>` è rappresentato come un singolo nodo `text`, e non come due nodi distinti.

Se al documento è associato uno schema (XML Schema), i nodi possono avere un tipo, come mostrato nei seguenti esempi 


![[Pasted image 20250405180933.png|500]]

## Espressioni di percorso

Le _Path Expressions_ (espressioni di percorso) possono essere utilizzate per estrarre valori da nodi e alberi XML, e per verificarne le proprietà. Come per qualsiasi altra espressione in XQuery, anche le espressioni di percorso elaborano sequenze.

Una espressione di percorso è costituita da una serie di passaggi (_steps_), separati dal carattere `/`. Ogni passaggio viene valutato in un contesto, cioè una sequenza di nodi (con informazioni aggiuntive, ad esempio la posizione del nodo), e produce a sua volta una sequenza. Il passaggio successivo viene valutato usando come contesto la sequenza di nodi prodotta dal passaggio precedente.

## Struttura di un passaggio

Ogni passaggio di una _Path Expression_ può essere composto da tre parti principali. La prima è un _asse_ (_axis_), che seleziona i nodi in base alla loro posizione rispetto al nodo di contesto; ad esempio, i figli vengono selezionati con `child::`. La seconda parte è un _test_, che filtra i nodi in base al loro nome e tipo; nell’esempio riportato, il nome è `section`. La terza parte consiste in uno o più _predicati_, che filtrano ulteriormente i nodi in base a criteri più generali; ad esempio, il predicato può escludere il primo figlio.

Un esempio completo è `child::section[position()>1]`, dove:

- **Asse**: `child::`
- **Nome/Tipo**: `section`
- **Predicato**: `[position() > 1]`

## Assi

Gli assi principali definiti in XQuery (e XPath) sono i seguenti, che verranno illustrati nei prossimi esempi:

`self::`  
`child::`  
`parent::`  
`ancestor::`  
`descendant::`  
`following-sibling::`  
`preceding-sibling::`  
`attribute::`

Esistono inoltre assi combinati:

`descendant-or-self::`  
`ancestor-or-self::`

## Predicati

Ogni passaggio di un'espressione di percorso può terminare con uno o più predicati (in congiunzione logica con `and`), racchiusi tra parentesi quadre `[` e `]`, per filtrare ulteriormente i nodi selezionati tramite assi e test su nomi o tipi. Un esempio è:

`child::section[1][attribute::xml:lang="it"]`

## Valutazione dei predicati

Se l'espressione del predicato è un valore atomico di tipo numerico, essa viene valutata come vera nel caso in cui la posizione dell’elemento corrisponda al valore numerico del predicato. Ad esempio:

`child::chapter[2]` restituisce solo il secondo figlio con il tag `<chapter>`.

Se l'espressione restituisce una sequenza vuota, il predicato viene considerato falso. Al contrario, se il primo elemento della sequenza è un nodo, il predicato restituisce vero. Ad esempio:

`child::chapter[child::title]` restituisce tutti i figli con tag `<chapter>` che contengono almeno un figlio con tag `<title>`.

Negli altri casi si seguono le pratiche standard per i predicati. Ad esempio:

`child::chapter[attribute::xml:lang = "it"]` restituisce tutti i figli con tag `<chapter>` che possiedono un attributo `xml:lang` con valore `"it"`.

## Espressioni di percorso complete

Un’espressione di percorso può anche iniziare con i seguenti prefissi:

Usare il carattere `/` indica che la sequenza di input dell’espressione contiene la radice dell’albero. Usare `//` indica invece che la sequenza di input contiene tutti i nodi del documento.

Alcuni esempi di espressioni di percorso complete:

`/descendant::figure[fn:position() = 42]` seleziona la quarantaduesima figura del documento.

`/child::book / child::chapter[5] / child::section[2]` seleziona la seconda sezione del quinto capitolo.

`//self::chapter[child::title]` seleziona tutti i capitoli che contengono almeno un figlio `<title>`.

## Sintassi abbreviata

Per scrivere espressioni più compatte, è possibile utilizzare alcune scorciatoie sintattiche:

L'omissione dell'asse `child::` consente di scrivere `child::section/child::paragraph` come `section/paragraph`.

La sostituzione dell'asse `attribute::` con il carattere `@` consente di scrivere `para[attribute::type="warning"]` come `para[@type="warning"]`.

La sostituzione di `descendant-or-self::node()` con `//` consente di scrivere `div/descendant-or-self::node()/child::paragraph` come `div//paragraph`.

La sostituzione di `self::node()` con il punto `.` consente di scrivere `self::node()/descendant-or-self::node()/child::para` come `.//para`.

La sostituzione di `parent::node()` con due punti `..` consente di scrivere `parent::node()/child::section` come `../section`.

## Espressioni FLWOR

Un'espressione FLWOR (pronunciata "flower") è simile a un'istruzione SQL del tipo _Select-From-Where_, ma è definita in termini di associazione di variabili. È composta da 5 parti, alcune delle quali opzionali:

**For**: associa una o più variabili a espressioni.  
**Let**: crea un alias dell’intero risultato di un’espressione.  
Le clausole _for_ e _let_ generano una lista con tutte le possibili associazioni, chiamate anche “tuple” nella specifica di XQuery.  
**Where**: filtra la lista di associazioni in base a una condizione.  
**Order by**: ordina la lista di associazioni.  
**Return**: crea il risultato dell’espressione FLWOR.

Queste espressioni, come qualunque altra espressione in XQuery, possono essere commentate usando i simboli `(:` e `:)`. È possibile anche annidare i commenti, come nel seguente esempio:

`(: Questo è un commento (: questo è un commento annidato :) :)`

## Iterazioni sugli elementi – clausola _for_

Per ogni libro, si vuole elencare l’anno e il titolo. Per prima cosa si selezionano tutti i libri nel documento XML:

`doc("example.xml")/bib/book`

Successivamente, per ciascun libro, che viene associato alla variabile `$b`, si scrive:

`for $b in doc("example.xml")/bib/book`

Infine si definisce il risultato da restituire:

```xquery
return <book year="{Estrazione dell’anno da $b, in XQuery}"> 
           {Estrazione del titolo da $b, in XQuery} 
       </book>
```

Le parentesi graffe `{}` delimitano un’espressione XQuery, che deve essere valutata per creare il risultato. All'interno della clausola `return` può essere specificata qualsiasi espressione XQuery. In questo caso, vengono utilizzati dei _costruttori_ che generano codice XML e che sono scritti in sintassi XML.

Valutando questa espressione, si ottiene una sequenza di nodi (associati alla variabile `$b`). Per ogni associazione della variabile `$b`, viene valutata la parte corrispondente dell’espressione.

# Iterazioni con filtro – clausola _where_

Per trovare i libri pubblicati da _Anchor Books_ dopo il 1991 si utilizza la seguente espressione:

```xquery
for $b in doc("example.xml")/bib/book
where $b/publisher = "Anchor Books" and $b/@year > 1991
return <book> { $b/title } </book>
```

Rispetto all’esempio precedente, è stato aggiunto un filtro attraverso la clausola `where`. La condizione specifica che il valore del nodo `publisher` sia uguale a `"Anchor Books"` e che l’attributo `year` del nodo `book` sia maggiore di `1991`.

# Espressioni con funzioni aggregate – clausola _let_

Talvolta è necessario raggruppare elementi tra loro, ad esempio per contarli, calcolarne il valore medio, minimo o massimo (nel caso si tratti di numeri).

Un esempio rappresentativo consiste nel voler elencare, per ogni sezione, il titolo e il numero di figure in essa contenute. Si può scrivere:

```xquery
<result> {
  for $s in .//section
  let $f := $s/figure
  return <section title="{ $s/title/text() }" numfig="{ fn:count($f) }"/>
} </result>
```

L’operatore `.//` seleziona tutti i discendenti del nodo corrente. La funzione `text()` restituisce il valore testuale del nodo. Il prefisso `fn:` indica che `count()` è una funzione standard di XQuery.

Ogni nodo `section` viene associato alla variabile `$s`. Per ogni sezione `$s`, la variabile `$f` corrisponde all’insieme degli elementi `figure` contenuti in quella sezione. Questa parte dell’espressione viene valutata una sola volta per ogni possibile associazione.

## Join in XQuery

Supponiamo di avere due file XML: uno descrive il programma di un concerto, l’altro descrive i compositori. In entrambi i file, il compositore è identificato tramite un identificatore comune.

Si vuole produrre una programmazione che elenchi i brani musicali, associando a ciascuno l’autore con le relative date di nascita e morte. L’espressione XQuery sarà la seguente:

```xquery
<program>{
  for $comp in fn:doc('comp.xml')/comp/composer,
      $song in fn:doc('conc.xml')/concert/song
  where $comp/id eq $song/author
  return <song>
           <title>{$song/title}</title>
           <of>{$comp/name}</of>
           <date>{$comp/bio}</date>
         </song>
}</program>
```

In questo caso, si utilizza una forma di _join_ tra due sorgenti XML diverse, basata sull’equivalenza tra il campo `id` del compositore e il campo `author` del brano musicale. La clausola `for` associa le variabili `$comp` e `$song` rispettivamente agli elementi `composer` e `song` nei due file. La clausola `where` filtra le combinazioni, selezionando solo quelle per cui l'identificatore dell’autore del brano corrisponde all’identificatore del compositore. La clausola `return` costruisce l’output in formato XML, con titolo del brano, nome del compositore e biografia (contenente le date di nascita e morte).

## Ordinamento – clausola _order by_

Come in SQL, anche XQuery fornisce una clausola per ordinare il risultato di un’espressione FLWOR. La clausola `order by` può essere specificata insieme a diversi parametri per modificarne il comportamento semantico.

Ad esempio, i dipendenti associati alla variabile `$employees` vengono restituiti ordinati in base al loro stipendio:

```xquery
for $i in $employees
order by $i/salary
return $i/surname
```

In questo caso, i dipendenti vengono restituiti in ordine crescente di stipendio.

Se si vuole ordinare i risultati in ordine decrescente di stipendio, si può scrivere:

```xquery
for $i in $employees
order by $i/salary descending
return $i/surname
```

Se invece si desidera ordinare il risultato di una query che altrimenti sarebbe scritta tramite una semplice espressione di navigazione, è necessario utilizzare un’espressione FLWOR. Ad esempio:

```xquery
for $i in $books//book[price < 50]
order by $i/title
return $i
```

In questo caso, vengono selezionati tutti i libri con prezzo inferiore a 50 e ordinati in base al titolo.

## Espressioni condizionali

I linguaggi di programmazione imperativi, come il linguaggio C, forniscono espressioni condizionali nella forma `if-then-else`. Anche in XQuery è possibile utilizzare costrutti simili. Questo permette di esprimere facilmente interrogazioni del tipo: aggiungere un elemento `<plateNumber>` se lo stato di un’auto in vendita è `"registered"`.

Ad esempio, la seguente espressione restituisce il valore della variabile `$productX` che contiene il prezzo più alto:

```xquery
if ($product1/price < $product2/price)
then $product2
else $product1
```

Questa query verifica l’esistenza di un attributo `@discounted`, selezionando conseguentemente gli elementi:

```xquery
if ($product/@discounted)
then $product/wholesale
else $product/retail
```

Per recuperare i titoli dei libri con un prezzo superiore a 30, si può usare una struttura condizionale più articolata:

```xquery
<result> {
  if(not(doc("books.xml")))
  then (
    <error>
      <message>books.xml does not exist</message>
    </error>
  )
  else (
    for $x in doc("books.xml")/books/book
    where $x/price > 30
    return $x/title
  )
} </result>
```

## Operatori di confronto

I seguenti operatori agiscono su sequenze composte da più elementi:

`=`, `!=`, `<`, `<=`, `>`, `>=`

Ad esempio, l’espressione:

```xquery
$book1/author = "Joyce"
```

restituisce `true` se almeno uno dei nodi `author` selezionati ha un valore testuale uguale a `"Joyce"`.

Questi operatori devono essere utilizzati con estrema cautela, come mostrano i seguenti esempi. Il fatto che gli operatori `=` e `!=` restituiscano `true` se almeno uno degli elementi delle sequenze confrontate soddisfa il predicato può produrre comportamenti controintuitivi:

Gli operatori **non sono transitivi**. Ad esempio:

(1,2)=(2,3)(1, 2) = (2, 3)  
(2,3)=(3,4)(2, 3) = (3, 4)  
(1,2)≠(3,4)(1, 2) \ne (3, 4)

Entrambe le seguenti espressioni restituiscono `true`:

(1,2)=(2,3)(1, 2) = (2, 3)  
(1,2)≠(2,3)(1, 2) \ne (2, 3)

XPath 2.0 introduce nuovi operatori per confrontare sequenze contenenti un solo elemento:

`eq`, `ne`, `lt`, `le`, `gt`, `ge`

Ad esempio:

```xquery
$book1/author eq "Joyce"
```

è `true` solo se viene selezionato un unico nodo `author`. In caso contrario, viene generato un errore.

## Operatori logici e aritmetici

XQuery fornisce i seguenti operatori logici, oltre a una funzione standard per la negazione logica:

- `or`, `and`  
- `fn:not()`

E i seguenti operatori aritmetici:

`+`, `-`, `*`, `div`, `idiv` (divisione intera), `mod` (resto della divisione)

Il risultato di un’espressione logica è un valore booleano o un errore.

Ad esempio, le seguenti espressioni restituiscono `true`:

```xquery
1 eq 1 and 2 eq 2
1 eq 1 or 2 eq 3
```

La seguente espressione può restituire `false` oppure generare un errore:

```xquery
1 eq 2 and 3 idiv 0 = 1
```

La seguente espressione può restituire `true` oppure generare un errore:

```xquery
1 eq 1 or 3 idiv 0 = 1
```


## Espressioni con quantificatori

In XQuery, una variabile può essere associata a un singolo valore. Ad esempio, `$price` può avere un valore intero pari a `12000`. Tuttavia, spesso le variabili sono associate a insiemi di oggetti. Per esempio, l’espressione:

```xquery
for $lib in doc("books.xml")/books/book
```

può associare la variabile `$lib` a più elementi `<book>`.

Per verificare proprietà sugli insiemi di oggetti, sono necessari operatori specifici. XQuery introduce due operatori per questo scopo, illustrati con i seguenti esempi:

```xquery
some $emp in //employee satisfies ($emp/salary > 13000)
```

Questa espressione restituisce `true` se almeno un dipendente riceve uno stipendio superiore a `13000`. Si tratta del **quantificatore esistenziale**.

Il risultato opposto si ottiene utilizzando il secondo quantificatore:

```xquery
every $emp in //employee satisfies ($emp/salary > 13000)
```

Questa espressione restituisce `true` se **tutti** i dipendenti ricevono uno stipendio superiore a `13000`. Si tratta del **quantificatore universale**.

## Funzioni di input

Le funzioni di input sono necessarie per ottenere il documento XML da interrogare. Esse permettono di accedere a un singolo documento oppure a una sequenza di documenti forniti dal sistema di gestione. Le principali sono:

```xquery
fn:doc("bib.xml")
fn:collection("composers")
```

## Funzioni su sequenze di nodi

Le seguenti funzioni operano su sequenze di nodi:

- `fn:position()`  
    Restituisce la posizione del nodo corrente all’interno del contesto.
- `fn:last()`  
    Restituisce un intero che rappresenta il numero di elementi nel contesto corrente. È spesso utilizzata per recuperare l’ultimo elemento.
- `fn:count($elements)`  
    Restituisce la cardinalità (cioè il numero di elementi) della sequenza di nodi passata come argomento.

## Funzioni aggregate

Le seguenti funzioni aggregate sono solitamente utilizzate in combinazione con la clausola `let`, come già visto:

- `count`
- `avg`
- `max`
- `min`
- `sum`

--- 
**Esempio.** Data la sequenza:

```xquery
$seq3 = (3, 4, 5)
```

si ottengono i seguenti risultati:

- `count($seq3)` restituisce `3`
- `avg($seq3)` restituisce `4`
- `max($seq3)` restituisce `5`
- `min($seq3)` restituisce `3`
- `sum($seq3)` restituisce `12`

---