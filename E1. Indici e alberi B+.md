
Un indice è una struttura dati ausiliaria che facilita l'accesso rapido ai dati. È definito da una chiave (formata da alcuni attributi) e una corrispondente etichetta. La chiave di ricerca non coincide necessariamente con la chiave primaria; può dunque avere valori duplicati. Salvo ambiguità, ci riferiamo a essa semplicemente come **chiave**. Un indice è formalmente una coppia $\langle \text{chiave},\,\text{etichetta} \rangle$ e permette il recupero efficiente di tutte le etichette associate a un determinato valore di chiave $K$.

![[Pasted image 20250311085752.png]]

## Etichette

Le etichette possono assumere diverse forme: 1) possono essere i record stessi, 2) l'identificatore del record (**RID**) corrispondente alla chiave $K$, oppure 3) una lista di RID dei record aventi la stessa chiave $K$. La rappresentazione delle etichette è indipendente dal metodo di ricerca utilizzato.


![[Pasted image 20250311085926.png]]


In un database è possibile avere al massimo un indice sui dati utilizzando la prima rappresentazione (cioè i record stessi). In questo caso, la dimensione dell'indice è uguale alla dimensione complessiva dei dati. Come osservato, la stessa chiave di ricerca (ad esempio $1010$) può essere associata a più valori duplicati. La terza rappresentazione (lista di RID) è la soluzione più compatta, ma comporta etichette di dimensioni variabili.

## Creare un indice in SQL

La sintassi generale più comune (anche se non standard SQL) per creare un indice è:

```sql
CREATE [UNIQUE] INDEX NomeIndice ON Tabella(ListaAttributi)
```

Un esempio concreto

```sql
CREATE INDEX EmpIdx ON Employee(Surname, Name)
```

Per eliminare un indice, invece, si utilizza

```sql
DROP INDEX NomeIndice
```

Ad esempio

```sql
DROP INDEX EmpIdx
```

**Nota.** il comando `CREATE INDEX` non fa parte dello standard SQL, ma è comunque largamente adottato nei principali DBMS.

---

 **Esempio. Indice su file sequenziale**

In un indice su file sequenziale, ogni chiave di ricerca presente nel file indice contiene un puntatore al record corrispondente nel file sequenziale. In questo scenario, la chiave di ricerca coincide con la chiave primaria della relazione:

$\text{chiave primaria} \rightarrow \text{puntatore al record}$

![[Pasted image 20250311091258.png|350]]

Questo permette di accedere rapidamente ai record nel file sequenziale, partendo dalla chiave primaria memorizzata nell'indice.

---

## Classificazione degli indici

Un indice si definisce **primario** se è basato su attributi che includono la chiave primaria e se i dati sono ordinati sugli stessi attributi. Se questa condizione non è soddisfatta, l'indice è detto **secondario**.

Un indice è **denso** se contiene almeno una voce per ogni valore della chiave di ricerca presente nel file dati. Se ciò non accade, si parla invece di indice **sparso**.

Un indice è detto **clustered** (o raggruppato) se l'ordine dei record nel file dati riflette (è uguale o simile) l'ordine delle etichette nell'indice. In caso contrario, l'indice è detto **unclustered** (non raggruppato).

---

**Esempio. Indice denso e clustered** 

![[Pasted image 20250311091435.png|300]]

**Indice sparso e clustered**

![[Pasted image 20250311091931.png|300]]

Lo spazio necessario per memorizzare un indice **sparso** è inferiore rispetto a quello richiesto da un indice **denso**, poiché quest'ultimo deve contenere almeno una voce per ogni valore di chiave presente nel file dati, mentre l'indice sparso contiene solo alcune chiavi selezionate.

**Indice secondario, denso e unclustered**

![[Pasted image 20250311092010.png|300]]

Gli indici **unclustered** rendono meno efficiente l'accesso ai dati, poiché record con lo stesso valore di chiave (ad esempio $2020$) possono trovarsi in blocchi distinti. Di conseguenza, per recuperarli, potrebbero essere necessarie più operazioni di lettura su blocchi diversi, aumentando i tempi di accesso rispetto agli indici **clustered**, dove record con la stessa chiave sono generalmente memorizzati in blocchi contigui.

---

**Esempio importante.**

Immaginiamo una relazione contenente 1.000.000 di tuple memorizzate in 100.000 blocchi da 4096 byte ciascuno. Lo spazio totale richiesto dai dati supera i 400 megabyte, troppo elevato per essere conservato e navigato efficientemente in memoria principale.

Supponiamo ora che il campo della chiave occupi 30 byte e i puntatori 8 byte. Considerando anche un ragionevole spazio per le intestazioni di blocco, possiamo memorizzare circa 100 coppie chiave-puntatore in un singolo blocco da 4096 byte.

Un indice **denso** richiederebbe dunque 10.000 blocchi, circa 40 megabyte in totale, dimensione ragionevole per essere conservata in memoria principale.

Utilizzando un indice denso e applicando una ricerca binaria, per individuare una chiave sarà necessario accedere a circa:

$log⁡210 000≈14\log_2 10\,000 \approx 14$

cioè circa 13 o 14 blocchi.

Inoltre, tenendo in memoria principale i blocchi più importanti, possiamo ridurre ulteriormente il numero di operazioni di I/O su disco necessarie per recuperare il record associato a una specifica chiave, ottenendo prestazioni notevolmente superiori.

---

## Indici a più livelli

Un indice **sparso** può essere utilizzato per ridurre ulteriormente il numero di blocchi necessari a memorizzare gli offset (puntatori) ai record.

In pratica, è possibile costruire un **indice degli indici**, ovvero un indice a più livelli. In questa struttura, un primo livello di indice punta a blocchi di un secondo livello, e così via, creando una gerarchia di indici sempre più compatti.

Questa tecnica consente di ridurre notevolmente il numero di blocchi letti durante le ricerche, migliorando l'efficienza di accesso:

$$(\text{indice di primo livello}) \rightarrow (\text{indice di secondo livello}) \rightarrow \dots \rightarrow (\text{record})$$

In questo modo, si riescono a gestire volumi di dati molto elevati mantenendo un numero ridotto di accessi ai blocchi.

## Alberi B+

L'utilizzo di indici a più livelli permette di velocizzare notevolmente le interrogazioni, rendendo il tempo di ricerca proporzionale al numero di livelli attraversati più il tempo necessario per scansionare l'elenco dei RID associati.

Una struttura dinamica molto diffusa nei sistemi commerciali è quella degli **alberi B** (_B-tree_). Questi alberi gestiscono automaticamente un numero appropriato di livelli di indice in base alla dimensione del file indicizzato.

Gli alberi B organizzano lo spazio nei blocchi, facendo in modo che ciascun blocco sia sempre utilizzato da metà fino alla completa capacità (ad eccezione della radice).

Ogni albero B è definito da un parametro $n$ che indica quanti valori di chiave e puntatori ciascun blocco può contenere: nello specifico, ogni blocco può ospitare fino a $n$ valori di chiave di ricerca e $n + 1$ puntatori.

Gli **alberi B+** (_B+ trees_) costituiscono una particolare tipologia degli alberi B, ottimizzati ulteriormente per i sistemi di database.

## Regole degli alberi B+

Gli alberi B+ sono definiti da alcune regole specifiche:

- Le chiavi contenute nei nodi foglia sono copie delle chiavi del file dati e sono ordinate da sinistra verso destra secondo l'ordinamento delle chiavi stesse.

- Nel nodo radice sono utilizzati almeno due puntatori (se ci sono almeno due record nei dati). Ciascun puntatore punta a un blocco del livello inferiore.

![[Pasted image 20250311094105.png]]

- Nei nodi interni, ogni puntatore utilizzato punta a un blocco del livello immediatamente inferiore; il numero minimo di puntatori utilizzati deve essere $\lceil (n+1)/2 \rceil$.

![[Pasted image 20250311094121.png]]


- Nei nodi foglia, l’ultimo puntatore punta sempre al nodo foglia successivo (a destra). Tra i rimanenti puntatori di un nodo foglia, almeno $\lfloor (n+1)/2 \rfloor$ puntatori devono essere utilizzati e puntano direttamente ai record dei dati.


![[Pasted image 20250311094436.png]]

## Alberi B+ e ricerca per uguaglianza

Supponiamo di voler cercare il record con chiave di ricerca uguale a $K = 40$.

La ricerca nell'albero B+ avviene nel seguente modo:

![[Pasted image 20250311094610.png]]

Si parte dalla radice e si confronta $K$ con le chiavi presenti nel nodo corrente per identificare il puntatore corretto verso il livello inferiore. Si procede in questo modo, livello dopo livello, fino ad arrivare al nodo foglia che dovrebbe contenere la chiave desiderata. Infine, nel nodo foglia si cerca la chiave esatta ($40$) per trovare il puntatore che porta al record cercato (o alla lista di record associati se ci sono duplicati).

## Alberi B+ e ricerca per intervallo

Supponiamo di voler cercare tutti i record aventi una chiave **maggiore** di $K=40$.

La ricerca nell'albero B+ avviene così:

![[Pasted image 20250311094825.png]]

Si identifica, partendo dalla radice, il nodo foglia che contiene il valore più piccolo superiore a $40$. Da questo punto, si scansionano verso destra i nodi foglia successivi sfruttando i puntatori di collegamento tra foglie, raccogliendo tutti i record con chiave maggiore di $40$. Questa struttura rende particolarmente efficiente la ricerca per intervalli, poiché i record sono già ordinati nei nodi foglia.

## Inserimento e cancellazione: variazione dell'altezza

Negli alberi B+, le operazioni di inserimento e cancellazione possono provocare una variazione dinamica dell'altezza della struttura.


![[Pasted image 20250311095117.png]]

In particolare:

- Durante l'**inserimento**, se un nodo è pieno, viene suddiviso in due nodi distinti ("split"). Ciò può causare la creazione di un nuovo livello superiore e aumentare l'altezza totale dell'albero.

- Durante la **cancellazione**, se un nodo risulta troppo vuoto (cioè ha meno del numero minimo di chiavi richieste), potrebbe essere necessario fondere ("merge") due nodi adiacenti o ridistribuire le chiavi tra nodi vicini. Questo processo può comportare la riduzione dei livelli e quindi diminuire l'altezza dell'albero.    

Tuttavia, l'albero B+ rimane sempre bilanciato: tutti i nodi foglia restano sempre allo stesso livello, garantendo tempi di accesso costanti ed efficienti.

## Inserimento negli alberi B+

L'inserimento negli alberi B+ è, in principio, una procedura ricorsiva:

Si cerca inizialmente la posizione corretta per la nuova chiave nel nodo foglia appropriato:

- Se c'è spazio nel nodo foglia, la nuova chiave viene inserita direttamente.    
- Se il nodo foglia è pieno, si divide ("split") il nodo in due nuovi nodi e le chiavi vengono distribuite equamente tra essi, mantenendo entrambi i nodi pieni almeno per metà.


Lo split di un nodo a un livello inferiore genera, nel livello superiore, la necessità di inserire una nuova coppia chiave-puntatore. Anche qui si applica ricorsivamente lo stesso principio:

- Se il nodo superiore ha spazio, la nuova coppia viene inserita direttamente.    
- Se il nodo superiore è pieno, si procede nuovamente con uno split, propagando verso l'alto questo processo.

Esiste una situazione particolare: quando la radice stessa è piena e si tenta un inserimento, si divide la radice in due nodi e viene creata una **nuova radice** al livello superiore.

**Nota importante.** Quando si esegue uno split di un nodo interno, la chiave centrale non rimane nei nodi appena creati, ma viene solo propagata verso l'alto al nodo genitore.


## Alberi B+ e inserimento: lookup (ricerca)

Supponiamo di voler inserire una nuova chiave $K=40$ nell'albero B+.

La procedura avviene così:

![[Pasted image 20250311095755.png]]

Partendo dalla radice, confrontiamo la chiave da inserire ($40$) con le chiavi presenti nei nodi interni, scegliendo il puntatore appropriato per scendere al livello inferiore. Si procede così fino a raggiungere il nodo foglia corretto, dove dovrebbe essere collocata la nuova chiave.

- Se il nodo foglia individuato ha spazio sufficiente, si inserisce direttamente $4040$.
- Se il nodo foglia è pieno, si esegue uno split del nodo e si procede eventualmente propagando l'inserimento verso i livelli superiori.

La ricerca prelimare della posizione segue dunque lo stesso percorso utilizzato per la ricerca per uguaglianza.

## Alberi B+ e inserimento: split (divisione)

Se il nodo foglia individuato per l’inserimento della nuova chiave non ha spazio sufficiente, si effettua uno **split** (divisione):

![[Pasted image 20250311100148.png]]

- Il nodo foglia pieno viene diviso in **due nuovi nodi**.
- Le chiavi del nodo originale, insieme alla nuova chiave, vengono distribuite equamente tra i due nuovi nodi, ciascuno dei quali deve essere riempito almeno per metà della sua capacità.
- La chiave più piccola del secondo nodo (chiave centrale nello split) viene propagata verso l'alto al nodo genitore (interno), insieme a un puntatore al nuovo nodo creato.
- Se necessario, il processo di split si propaga verso i livelli superiori dell'albero.


In questo modo, l’albero B+ rimane sempre bilanciato, mantenendo elevate prestazioni di ricerca.

## Alberi B+ e inserimento: propagazione

Quando avviene uno split (divisione) di un nodo a un determinato livello dell'albero B+, al livello superiore si presenta la necessità di inserire una nuova coppia **chiave-puntatore**:

![[Pasted image 20250311102327.png]]

- La **chiave centrale**, risultato dello split del nodo inferiore, viene propagata verso l'alto.
- Se il nodo superiore ha spazio sufficiente, la nuova coppia chiave-puntatore viene semplicemente inserita.
- Se anche il nodo superiore risulta pieno, si procede a un ulteriore split, e il processo si ripete ricorsivamente verso l’alto fino a raggiungere eventualmente la radice.
- Se durante questo processo viene raggiunta la radice e anche quest’ultima è piena, si crea una **nuova radice** che aggiunge un ulteriore livello all'albero.


![[Pasted image 20250311100258.png]]

Questo meccanismo mantiene sempre bilanciato l'albero B+, assicurando alte prestazioni in termini di efficienza delle operazioni di ricerca e inserimento.

## Cancellazione negli alberi B+

La cancellazione negli alberi B+ avviene secondo una procedura ricorsiva:

Si cerca innanzitutto la chiave nel nodo foglia e si elimina. Non è necessario eliminare tale chiave dai nodi intermedi.

- Se dopo la cancellazione il nodo foglia contiene ancora almeno il numero minimo di chiavi, la procedura termina.

Altrimenti, si procede come segue:

- Se uno dei nodi fratelli adiacenti al nodo corrente possiede più del numero minimo di chiavi, si trasferisce una coppia chiave-puntatore dal fratello al nodo corrente (ridistribuzione). È necessario aggiornare di conseguenza le chiavi nel nodo genitore.

- Se entrambi i nodi fratelli adiacenti non hanno chiavi in eccesso, si effettua una **fusione** (merge) dei due nodi, formando un unico nodo. Anche in questo caso, le chiavi nel nodo genitore devono essere aggiornate.

- Se, a seguito di questo processo, il nodo genitore scende sotto il numero minimo di chiavi consentito, si applica ricorsivamente la stessa procedura di cancellazione sul genitore, propagando eventualmente verso l’alto fino alla radice.

Questa procedura mantiene sempre bilanciato l'albero B+, assicurando prestazioni efficienti anche dopo la cancellazione.

## Alberi B+ e cancellazione: lookup (ricerca)

Stiamo cercando la foglia contenente la chiave $K = 7$ da eliminare.

![[Pasted image 20250311100623.png]]


## Alberi B+ e cancellazione: ribilanciamento

La seconda foglia ora contiene un solo valore chiave, mentre ogni foglia deve avere almeno due chiavi.

![[Pasted image 20250311101105.png]]

Poiché la chiave più bassa nella seconda foglia è ora $5$, la chiave nel nodo padre delle prime due foglie è stata modificata da $7$ a $5$.

![[Pasted image 20250311101210.png]]


## Alberi B+ e cancellazione: ricerca

Stiamo cercando la foglia contenente la chiave $K = 11$ da eliminare.

![[Pasted image 20250311101307.png]]


## Alberi B+ e cancellazione: merge

Non è possibile prendere in prestito una chiave dalla prima foglia. Inoltre, non esiste un nodo fratello a destra da cui poter prelevare una chiave. Di conseguenza, è necessario fondere la seconda foglia con un nodo fratello, ovvero la prima foglia.

![[Pasted image 20250311101437.png]]


## Alberi B+ e cancellazione: ribilanciamento

I puntatori e le chiavi nel nodo padre vengono aggiornati per riflettere la nuova situazione nei nodi figli. La chiave $5$ non è più rilevante e viene eliminata.


![[Pasted image 20250311101458.png]]


## Complessità della ricerca negli alberi B+

La complessità della ricerca dipende dall'altezza dell'albero B+, indicata con $L$, ovvero il numero di livelli.

Supponiamo di avere $N$ foglie e, in media, $\dfrac{n}{2}$ puntatori per foglia. Qual è l'altezza risultante dell'albero B+?

Al primo livello abbiamo un solo nodo, ovvero la radice. Al secondo livello ci sono $\dfrac{n}{2}$ nodi, per ipotesi. Al terzo livello il numero di nodi diventa $\left(\dfrac{n}{2}\right)^2$, e così via fino al livello $L$, dove il numero di nodi è dato da $\left(\dfrac{n}{2}\right)^{L-1}$. 

Dalla relazione 

$\left(\dfrac{n}{2}\right)^{L-1} \leq N \leq \left(\dfrac{n}{2}\right)^L$

possiamo ricavare il limite inferiore e superiore dell'altezza $L$, ottenendo:

$L - 1 \leq \log_{\dfrac{n}{2}} N$  e  $L \geq \log_{\dfrac{n}{2}} N$

Da cui segue che:

$\log_{\dfrac{n}{2}} N \leq L \leq \log_{\dfrac{n}{2}} N + 1$
