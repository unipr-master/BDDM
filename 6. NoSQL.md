## DBMS Relazionali

I sistemi di gestione di database relazionali (Relational DBMS) si basano su un solido fondamento teorico, rappresentato dal modello relazionale. La loro struttura è altamente organizzata, con dati organizzati in righe e colonne e definiti da tipi specifici. L’interrogazione e la manipolazione dei dati avvengono attraverso il linguaggio SQL, standardizzato per garantire compatibilità e uniformità. Uno degli aspetti fondamentali di questi sistemi è il rispetto delle proprietà ACID, che assicurano che le operazioni vengano eseguite completamente o non vengano eseguite affatto. Inoltre, la capacità di effettuare operazioni di join consente di creare nuove viste a partire dalle relazioni tra le tabelle.

Con l’avvento dei Big Data, il panorama dei dati è cambiato significativamente. Le caratteristiche chiave di questa nuova realtà si riassumono nelle cosiddette cinque (o sei) "V": volume, velocità, varietà, variabilità, veridicità e valore. Per affrontare queste sfide, i sistemi di gestione dei dati devono adottare schemi più flessibili o, in alcuni casi, eliminare del tutto la necessità di uno schema rigido. La distribuzione dei dati diventa essenziale per gestire grandi volumi, mentre la necessità di un’elevata disponibilità è cruciale per garantire una gestione efficiente dell’elevata velocità con cui vengono generati i dati.

Un esempio concreto riguarda i veicoli autonomi. Un veicolo con un basso livello di autonomia può generare circa 3 Gbit al secondo, ovvero circa 1,4 terabyte di dati ogni ora. Con livelli di autonomia più elevati, la larghezza di banda complessiva dei sensori può arrivare a 40 Gbit al secondo, generando circa 19 terabyte di dati all’ora. Su base annua, un veicolo può produrre 434 terabyte di dati a livelli di autonomia più bassi, mentre un sistema ad alta autonomia può arrivare a generare fino a 5.894 terabyte.

Nonostante i vantaggi, i database relazionali presentano alcune debolezze. L’uso dei join, sebbene utile per la creazione di relazioni tra i dati, non è scalabile con grandi volumi di informazioni. Le operazioni di lettura e scrittura possono risultare lente a causa della necessità di bloccare le risorse per mantenere la coerenza delle transazioni. Inoltre, la struttura rigida dello schema rende difficile lavorare con dati altamente variabili. L’integrazione di documenti e la generazione di report basati su dati sia strutturati che non strutturati possono risultare complesse, limitando l’efficacia dei sistemi relazionali in contesti di Big Data.

## NoSQL

Nel 2004, aziende come Google e Amazon svilupparono i propri database non relazionali per gestire enormi quantità di dati, evitando l’uso di chiavi primarie e esterne, JOIN e calcoli relazionali tradizionali. Questi database, come Google BigTable e Amazon Dynamo, furono progettati per scalare fino a petabyte di dati distribuiti su migliaia di macchine. Nel 2008, anche Facebook introdusse un proprio database non relazionale con un’architettura simile a quella di Google BigTable, offrendo una soluzione cloud per la gestione dei dati NoSQL.

Oltre alla necessità di scalabilità, uno dei motivi principali che spinsero verso l’adozione di database NoSQL fu il costo delle licenze SQL per infrastrutture con centinaia di migliaia di macchine. Nel 2009, l’hashtag  `#NoSQL` nacque su Twitter in occasione di una conferenza dedicata a questi nuovi sistemi, sebbene il termine non abbia mai avuto una definizione univoca. NoSQL può essere interpretato come "non SQL", "non relazionale" o "not only SQL", senza però indicare in modo preciso le caratteristiche tecniche di questi database.

Attualmente, esistono più di 225 diversi sistemi di database NoSQL, che si distinguono dai tradizionali database relazionali per alcune caratteristiche fondamentali. A differenza dei sistemi relazionali che rispettano le proprietà ACID, i database NoSQL seguono invece il modello BASE, privilegiando la disponibilità e la scalabilità rispetto alla coerenza assoluta. Un altro elemento distintivo è l’assenza di uno schema rigido: questi database adottano modelli di dati non relazionali, come quelli basati su chiave-valore, documenti o grafi, permettendo una maggiore flessibilità nella gestione delle informazioni.

## SQL (ACID) vs NoSQL (BASE)

I database relazionali (SQL) adottano il modello **ACID**, che garantisce un'elevata coerenza dei dati, ma sacrifica la disponibilità in determinate situazioni. ACID comprende quattro principi fondamentali: **Atomicità**, che assicura che ogni transazione sia eseguita completamente o annullata in caso di errore; **Coerenza**, che impone che i dati rimangano validi e rispettino tutte le regole definite; **Isolamento**, che evita che le transazioni interferiscano tra loro; e **Durabilità**, che garantisce che i dati confermati non vadano persi, anche in caso di guasto del sistema. Questo approccio utilizza quindi una **concorrenza pessimistica**, in cui le transazioni vengono rigidamente controllate per evitare inconsistenze, rendendo il sistema più complesso e meno scalabile. Le operazioni seguono regole ben definite, verificando la coerenza a ogni passaggio prima di procedere con la successiva.

I database NoSQL, invece, si basano sul principio **BASE**, dove la disponibilità è prioritaria e altre proprietà, come la coerenza, vengono parzialmente sacrificate per garantire prestazioni elevate e scalabilità. Questo modello segue un approccio **ottimistico**, caratterizzato da una consistenza più debole e dall’uso del concetto di **consistenza eventuale**, in cui i dati si propagano gradualmente fino a diventare coerenti nel tempo. Il sistema non verifica la coerenza di ogni transazione prima di procedere con la successiva, ma si affida a una gestione più flessibile dei dati. BASE si compone di tre principi principali: 

- **Basic Availability**: il sistema garantisce sempre una risposta, anche se potrebbe trattarsi di un errore o di dati incoerenti. Questa proprietà è strettamente legata al **Teorema CAP**, che stabilisce un compromesso tra coerenza, disponibilità e tolleranza alle partizioni.
- **Soft State**: lo stato del sistema può cambiare nel tempo, anche senza nuovi input. Questo è dovuto al concetto di consistenza eventuale, che permette ai dati di propagarsi gradualmente in tutto il sistema.
- **Eventual Consistency**: i dati non sono immediatamente coerenti in tutto il sistema, ma raggiungono uno stato consistente nel tempo. Il sistema continua a ricevere nuovi input mentre i dati vengono sincronizzati, senza bloccare le operazioni in attesa della coerenza assoluta.

Il modello ACID privilegia la **forte coerenza**, ma ha una disponibilità minore e una gestione della concorrenza più rigida e complessa. Il modello BASE, al contrario, mette al primo posto la **disponibilità**, accettando una coerenza più debole, un funzionamento più semplice e veloce, e un approccio più scalabile. Tuttavia, non è possibile ottenere entrambi i modelli contemporaneamente, poiché esiste un **trade-off** tra coerenza, disponibilità e tolleranza alle partizioni, come descritto nel **Teorema CAP**.

## Il Teorema CAP e il trade-off nei sistemi distribuiti

Il **Teorema CAP**, noto anche come "Teorema di Brewer", afferma che un sistema di gestione dei dati distribuito può garantire al massimo due delle seguenti tre proprietà contemporaneamente:

- **Coerenza (Consistency)**: tutti i nodi del sistema vedono sempre gli stessi dati in ogni momento. Questo concetto è simile alla coerenza definita nel modello ACID, dove ogni operazione deve mantenere il sistema in uno stato valido e coerente.

- **Disponibilità (Availability)**: ogni richiesta ricevuta dal sistema deve ricevere una risposta, indipendentemente dal successo o dal fallimento dell'operazione. Anche in caso di guasti, il sistema deve garantire la sua operatività.

- **Tolleranza alle Partizioni (Partition Tolerance)**: il sistema deve essere in grado di continuare a funzionare anche se alcune delle sue parti non possono comunicare tra loro a causa di guasti o perdita di dati.

## Il dilemma CAP

Poiché è impossibile ottenere simultaneamente tutte e tre le proprietà, i database e i sistemi distribuiti scelgono di privilegiare due di esse:

**CP (Coerenza e Tolleranza alle Partizioni)**

- Il sistema garantisce la coerenza e la resistenza alle partizioni, ma potrebbe sacrificare la disponibilità.
- Esempi: **BigTable, HBase, MongoDB (configurato per garantire coerenza)**.

**AP (Disponibilità e Tolleranza alle Partizioni)**

- Il sistema è sempre disponibile e resiste alle partizioni di rete, ma la coerenza può essere solo eventuale.
- Esempi: **Cassandra, CouchDB, DynamoDB, Voldemort**

**CA (Coerenza e Disponibilità)**
 
- Il sistema è coerente e sempre disponibile, ma non può tollerare partizioni di rete. Questo modello è tipico dei database relazionali centralizzati, che non sono distribuiti su più nodi.
- Esempi: **RDBMS come MySQL, SQL Server, Oracle**.

## Il trade-off tra ACID e BASE

Nei sistemi **relazionali**, la priorità è garantire la **coerenza forte (ACID)**, spesso sacrificando la disponibilità o la scalabilità. Nei sistemi **NoSQL e distribuiti**, invece, la priorità è garantire **disponibilità e tolleranza alle partizioni (BASE)**, accettando una coerenza più debole e ritardata nel tempo (consistenza eventuale).

In pratica, i sistemi su larga scala come i database NoSQL scelgono **disponibilità e tolleranza alle partizioni** (AP), riducendo la coerenza immediata per migliorare la scalabilità. Questo compromesso è necessario per affrontare le esigenze dei moderni sistemi distribuiti, come quelli utilizzati nei social network, nei motori di ricerca e nei servizi cloud.

## Schema fisso vs schema-less

Uno dei principali punti di distinzione tra **database relazionali** (SQL) e **database NoSQL** è la gestione dello **schema** dei dati. Mentre nei sistemi relazionali i dati devono rispettare una struttura predefinita e rigida, i database NoSQL adottano un approccio più flessibile e dinamico, eliminando la necessità di uno schema fisso.

#### Caratteristiche dei Database Relazionali (Schema Fisso)

Ogni tabella in un database relazionale deve seguire uno schema predefinito, con campi e tipi di dati ben definiti. L’inserimento di un record è possibile solo se rispetta la struttura stabilita dallo schema. Per gestire dati opzionali, è necessario utilizzare il valore **NULL** nei campi non compilati. I tipi di dati devono essere rispettati rigidamente, impedendo, ad esempio, l’inserimento di una stringa in un campo numerico. Inoltre, non è possibile memorizzare più valori all'interno dello stesso campo: per rappresentare relazioni tra dati, occorre creare più tabelle e stabilire collegamenti tra di esse attraverso **chiavi primarie e chiavi esterne**, seguendo le regole di **normalizzazione**.

#### Caratteristiche dei database NoSQL (Schema-Less)

Le database NoSQL, definiti **schema-less**, non prevedono uno schema fisso, consentendo ai dati di variare da un documento all’altro senza vincoli rigidi. Ogni documento include esclusivamente le informazioni necessarie, evitando la presenza di celle inutilizzate. Inoltre, i tipi di dati sono impliciti, garantendo una maggiore flessibilità nella gestione delle informazioni. Il controllo dei dati avviene direttamente a livello dell’applicazione, piuttosto che essere imposto dal database. L'organizzazione dei dati si basa su **aggregati (documenti)**, dove tutte le informazioni pertinenti vengono archiviate insieme, riducendo la necessità di JOIN e migliorando la scalabilità complessiva del sistema.

I **database relazionali (SQL)** sono più indicati per contesti in cui la struttura dei dati è ben definita, la coerenza è un requisito fondamentale e le operazioni transazionali risultano complesse. Al contrario, i **database NoSQL** sono la scelta ideale quando si privilegiano flessibilità, scalabilità e rapidità di accesso ai dati, in particolare nelle applicazioni distribuite, come social media, e-commerce e big data.

## Aggregazione nei database NoSQL e modelli di dati

L'**aggregazione** è un concetto chiave nei database NoSQL, derivato dal **Domain-Driven Design (DDD)**. Un aggregato rappresenta un insieme di oggetti correlati trattati come un'unica unità. Ad esempio, un documento web può includere un titolo, un corpo di testo, immagini e didascalie, tutti archiviati insieme. Questo approccio riduce la necessità di operazioni di **JOIN**, tipiche dei database relazionali, migliorando le prestazioni e facilitando l’accesso ai dati. Inoltre, le transazioni nei database NoSQL non attraversano i confini degli aggregati, garantendo un modello più efficiente per la gestione dei dati su larga scala.

Nei database NoSQL esistono diversi **modelli di dati**, ciascuno progettato per rispondere a esigenze specifiche. I **database a documenti** archiviano dati in formato JSON, BSON o XML, rendendoli ideali per applicazioni web e contenuti dinamici, come accade in MongoDB e CouchDB. I **database a grafi**, come Neo4j, sono ottimizzati per rappresentare connessioni e relazioni complesse, risultando utili nei social network e nei motori di raccomandazione. I **database a colonne**, come Apache Cassandra, organizzano i dati in colonne anziché in righe, permettendo analisi efficienti su grandi volumi di dati, spesso utilizzati in ambito di big data e data warehousing. I **database a chiave-valore**, come Redis e DynamoDB, offrono un accesso estremamente rapido alle informazioni, essendo ideali per caching e gestione delle sessioni in tempo reale.

La scelta di un modello rispetto a un altro dipende dalle esigenze dell’applicazione. Alcune necessitano di accesso a dati temporanei, altre di archiviazione storica, mentre altre ancora richiedono velocità di accesso elevate. L’uso di un unico database per tutte le esigenze può risultare inefficiente, motivo per cui molte architetture moderne adottano la **Polyglot Persistence**, un approccio ibrido che combina diversi database specializzati all’interno dello stesso sistema. Questo permette di sfruttare i vantaggi di ogni tecnologia, ottenendo una maggiore scalabilità e prestazioni ottimali in base alle specifiche esigenze dell’applicazione.

## Il modello di dati key-value 

Il **modello di dati key-value** è una delle strutture più semplici nei database NoSQL. Ogni dato viene memorizzato come una coppia chiave-valore, dove la chiave è un identificatore univoco e il valore può essere un semplice dato testuale, un oggetto JSON o un documento binario. Questo tipo di architettura è progettato per gestire **carichi di dati enormi**, garantendo accesso rapido e scalabilità.

I database key-value possono operare **in memoria** per ottenere prestazioni elevate, oppure essere supportati da **persistenza su disco** per garantire la conservazione dei dati. Un'altra caratteristica distintiva di questo modello è il **versioning**, che consente di gestire più versioni dello stesso dato, utile per scenari in cui la coerenza immediata non è prioritaria.

Questa struttura è ideale per applicazioni che richiedono accesso rapido ai dati, come **sistemi di caching, gestione delle sessioni e archiviazione di configurazioni**. Alcuni esempi di database key-value includono **Voldemort (usato da LinkedIn), Amazon SimpleDB, Redis, Memcache, BerkleyDB e Oracle NoSQL**.

Il **modello key-value** si basa su coppie _(chiave, valore)_, in cui i dati vengono memorizzati in una struttura simile a una **hash table**. Il valore associato a una chiave può essere di qualsiasi formato, senza un vincolo di schema predefinito. L’accesso ai dati avviene tramite chiavi univoche, il che rende questo sistema estremamente veloce ed efficiente.

Le operazioni principali di un database key-value includono:

- **Insert(key, value)** per aggiungere nuovi dati.
- **Fetch(key)** per recuperare un valore in base alla chiave associata.
- **Update(key, value)** per modificare un dato già esistente.
- **Delete(key)** per eliminare una chiave e il valore associato.

### Come funziona un key-value store nella pratica

Il valore memorizzato viene trattato come un **blob** (Binary Large Object), il che significa che il database **non interpreta il contenuto** né impone restrizioni sul formato o sulla lunghezza. La responsabilità di comprendere e gestire il significato del valore è demandata all’applicazione che utilizza il database.

Amazon, attraverso il suo database **DynamoDB**, ha osservato che molti servizi della sua piattaforma necessitano **solo di accesso tramite chiave primaria**, senza bisogno di strutture più complesse. Esempi di utilizzo del modello key-value includono la gestione di **liste dei bestseller, carrelli della spesa, preferenze dei clienti, session management, ranking di vendita e cataloghi di prodotti**. Grazie alla sua semplicità e scalabilità, il modello key-value è ampiamente utilizzato per applicazioni che richiedono **accesso rapido ai dati e alta disponibilità**.

## Il modello di dati a documenti 

Il **modello document-based** organizza i dati sotto forma di documenti, che possono essere rappresentati in **XML, JSON, testo o come blob binari**. Questo tipo di database permette di strutturare informazioni in una gerarchia ad albero, rendendo più semplice la rappresentazione di dati complessi. Ad esempio, un ordine può essere archiviato come un singolo documento contenente l’indirizzo di consegna, i dettagli di fatturazione e la lista dei prodotti con relative quantità.

A differenza del modello **key-value**, in cui il valore è un semplice blob non interpretato, nei database a documenti il **valore stesso è un documento strutturato**. Questo permette di effettuare ricerche più avanzate sui dati, mantenendo un’organizzazione chiara e naturale. Alcuni esempi di database basati su documenti sono **MongoDB, Couchbase, RavenDB, ArangoDB, MarkLogic, OrientDB, Redis e RethinkDB**.

### Vantaggi del modello a documenti

Uno dei principali benefici di questo modello è la sua **flessibilità e ricchezza nella rappresentazione dei dati**. I documenti possono includere **sotto-documenti e array**, evitando la necessità di distribuire informazioni su più tabelle come avviene nei database relazionali. Grazie a questa struttura, il modello document-based consente di **eseguire query avanzate e creare indici su qualsiasi elemento** del documento, migliorando le prestazioni delle operazioni di ricerca.

Un altro vantaggio è che i dati vengono **aggregati in una singola struttura** (pre-JOINed), evitando la necessità di operazioni JOIN complesse tipiche dei database SQL. Questo semplifica lo sviluppo applicativo, migliora le prestazioni su larga scala e permette una maggiore agilità nello sviluppo software, consentendo di **adattare il modello dei dati in modo dinamico senza dover ridefinire uno schema rigido**.

### Relazionale vs modello a documenti: join vs aggregazione

Nei database relazionali, dati complessi vengono suddivisi in più tabelle, con relazioni definite tramite chiavi primarie e chiavi esterne. Questo comporta la necessità di operazioni **JOIN**, che possono diventare costose in termini di prestazioni quando i dati aumentano. Nel modello a documenti, invece, **gli oggetti complessi vengono mantenuti in un unico documento**, eliminando la necessità di join e migliorando l’efficienza dell’accesso ai dati. Inoltre, grazie alla natura **schema-less**, non è necessario definire una struttura fissa a priori, consentendo maggiore flessibilità e velocità nello sviluppo applicativo.

### Relazionale vs modello a documenti: operazioni sui dati

Il **modello relazionale** e il **modello document-based** gestiscono le operazioni sui dati in modi diversi. Nei database relazionali, le informazioni sono suddivise in più tabelle collegate da chiavi primarie e chiavi esterne, il che richiede operazioni **JOIN** per ricostruire i dati. Nel modello a documenti, invece, i dati vengono **aggregati in un unico documento** o distribuiti in collezioni, semplificando le operazioni di lettura e scrittura.

---

**Esempio di Operazioni nei Due Modelli.**

**Creazione di un Prodotto**

Nel modello relazionale, la creazione di un nuovo prodotto richiede più operazioni **INSERT** su diverse tabelle, come la descrizione del prodotto, il prezzo e il produttore. Nel modello a documenti, invece, è sufficiente una singola operazione **insert()** su un documento che include tutti i dettagli del prodotto, organizzati in **sotto-documenti e array**.

**Visualizzazione di un Prodotto**

Per visualizzare un prodotto, un database relazionale deve eseguire un’operazione **SELECT** con **JOIN** su più tabelle per ricostruire tutte le informazioni. Nei database a documenti, invece, un’unica operazione **find()** permette di recuperare l’intero documento aggregato, migliorando l'efficienza della query.

**Aggiunta di una Recensione**

Nel modello relazionale, una recensione viene inserita in una tabella separata e collegata al prodotto tramite una chiave esterna. Nel modello document-based, la recensione può essere **memorizzata direttamente all’interno del documento del prodotto** oppure in una **collezione separata** con un riferimento al documento del prodotto, rendendo l'accesso ai dati più flessibile.

---

Il modello **relazionale** è più adatto a scenari in cui la **consistenza forte** è una priorità e le informazioni devono essere normalizzate per garantire integrità. Tuttavia, il modello **document-based** offre un approccio più efficiente per applicazioni che richiedono velocità, scalabilità e flessibilità, eliminando la necessità di JOIN complessi e permettendo una gestione più naturale dei dati.

### Il modello di dati a colonne 

Il **modello columnar** (a colonne) è un'estensione delle tradizionali strutture tabellari, ma invece di memorizzare i dati **riga per riga**, li organizza **colonna per colonna**. Questo significa che, invece di archiviare una riga completa di dati in un’unica operazione, i valori di ogni colonna vengono salvati separatamente. Ad esempio, in una tabella con ID, cognome, nome e bonus, un database relazionale memorizzerebbe ogni riga come una singola unità, mentre un database columnar salverebbe tutti gli ID insieme, tutti i cognomi insieme, e così via.

Questa struttura offre un significativo vantaggio in termini di **prestazioni** per operazioni che riguardano intere colonne, come conteggi, somme o medie. I database columnar supportano insiemi variabili di colonne (note come **famiglie di colonne**) e ottimizzano le operazioni su larga scala. Inoltre, grazie alla **compressione**, il modello columnar consente di ridurre lo spazio di archiviazione, poiché ogni colonna contiene dati dello stesso tipo.

### Struttura e vantaggi del modello a colonne

Il **valore più piccolo memorizzato** in un database columnar è la singola colonna, che viene archiviata come una **tupla contenente una chiave, un valore e un timestamp**. Ogni chiave può avere più colonne associate, permettendo di modellare dati in modo più flessibile rispetto a un database relazionale tradizionale.

Alcuni esempi di database basati su modello columnar includono **Cassandra, HBase, Amazon Redshift, HP Vertica e Teradata**. Questi sistemi sono ottimizzati per **analisi di grandi volumi di dati** e vengono spesso utilizzati per **Big Data e data warehousing**.

---

**Prestazioni: Il caso di Facebook con Cassandra**

L’adozione di un database columnar può portare a un miglioramento drastico delle prestazioni. Ad esempio, Facebook ha sostituito MySQL con Cassandra per gestire il proprio motore di ricerca interno, ottenendo un incremento di velocità sorprendente. Con MySQL, la scrittura di dati da **50 GB** richiedeva in media **300 ms**, mentre la lettura ne richiedeva **350 ms**. Con Cassandra, gli stessi dati venivano scritti in **0.12 ms** e letti in **15 ms**, rendendo il sistema **2.500 volte più veloce**.

---

Il modello di database a colonne è particolarmente utile per applicazioni che richiedono **analisi su larga scala, operazioni intensive su dati strutturati e gestione efficiente delle query analitiche**. È meno adatto per operazioni transazionali tradizionali, ma offre vantaggi significativi in termini di **scalabilità, compressione ed efficienza delle query su colonne specifiche**.

### Il modello di dati a grafo

Il **modello a grafo** organizza i dati secondo una **struttura a nodi e relazioni**, basandosi sulla **teoria dei grafi**. Questo tipo di database è progettato per rappresentare connessioni complesse tra entità, rendendolo ideale per analizzare reti di relazioni, come quelle nei social network, nei motori di raccomandazione e nei sistemi di gestione delle dipendenze.

Il modello utilizza il concetto di **property graph**, dove:

- I **nodi** rappresentano entità (ad esempio, persone, aziende o prodotti).
- Le **relazioni** collegano i nodi e possono avere direzioni (es. "segue", "acquista", "amico di").
- Le **proprietà** sono informazioni associate sia ai nodi che alle relazioni (ad esempio, un nodo "Utente" può avere una proprietà "Nome", mentre una relazione "Acquista" può avere una proprietà "Data").

I database a grafo **non utilizzano clustering per la scalabilità orizzontale**, ma crescono principalmente in modo **verticale**. Tuttavia, permettono di eseguire facilmente **algoritmi di analisi sui grafi**, come il calcolo del percorso più breve, il rilevamento di comunità e l’identificazione di nodi altamente connessi.

A differenza di altri database NoSQL, i database a grafo sono **ACID-compliant**, garantendo transazioni affidabili e coerenti. Alcuni esempi di database basati su grafi includono **Neo4j, InfiniteGraph, OrientDB e Titan GraphDB**.

### Quando usare un database a grafo?

Questi database sono particolarmente utili quando le relazioni tra i dati sono **più importanti dei dati stessi**. Ad esempio, nei social network servono per analizzare connessioni tra utenti, nei sistemi di raccomandazione per suggerire prodotti basati su interessi comuni e nella cybersecurity per individuare minacce analizzando connessioni tra eventi sospetti.

Grazie alla loro efficienza nel gestire relazioni complesse, i database a grafo stanno diventando sempre più popolari in applicazioni che richiedono analisi avanzate e navigazione rapida tra dati interconnessi.