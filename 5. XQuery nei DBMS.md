Mostreremo diverse query XQuery eseguite su differenti sistemi di gestione di database. I documenti che verranno interrogati sono _Employees.xml_ e _Departments.xml_, i quali rappresentano rispettivamente i dipendenti di un'azienda e i dipartimenti in cui lavorano. Questi due documenti sono collegati tramite l'attributo _deptno_, che sarà utilizzato per effettuare eventuali operazioni di join.

![[Pasted image 20250305140007.png]]


![[Pasted image 20250305140029.png]]

## XQuery e DB2

DB2 consente di inserire colonne di tipo XML all'interno di tabelle relazionali, permettendo così di inserire dati utilizzando i normali comandi _INSERT_ in combinazione con la funzione _XMLPARSE_. Quest'ultima riceve in input una stringa e, se possibile, la converte in un frammento XML che il DBMS può gestire. Poiché viene utilizzato il tipo XML, il database deve adottare la codifica UTF-8, opzione selezionabile durante la sua creazione. Le query XQuery vengono inserite nella clausola _SELECT_ delle query SQL attraverso la funzione _XMLQUERY_, restituendo frammenti XML. Inoltre, è possibile combinare query relazionali e query XQuery utilizzando altre funzioni specifiche: _XMLEXISTS_ può essere impiegata nella clausola _WHERE_, mentre _XMLTABLE_ viene utilizzata nella clausola _FROM_.
#### Path expression

DB2 offre pieno supporto a tutti gli assi dell'espressione di percorso, a tutti i tipi di nodo e ai test richiesti dallo standard XPath. Ad esempio, l'espressione `/descendant-or-self::book[attribute::year>1992]` seleziona tutti gli elementi _book_ appartenenti all'asse _descendant-or-self_ che possiedono un attributo _year_ con un valore superiore al 1992. Un altro esempio è l'espressione `/child::bib/child::book/child::text()`, che seleziona tutti gli elementi di tipo testo che sono figli di un elemento _book_, il quale a sua volta è figlio di un elemento _bib_.

#### Creazione di una tabella XML

Per iniziare la nostra serie di esempi, è necessario creare le tabelle in grado di contenere dati XML. Per farlo, è sufficiente specificare _XML_ come tipo di dato per una colonna. Nel nostro caso, vogliamo definire due tabelle, ognuna delle quali conterrà uno dei documenti menzionati in precedenza. Un esempio di creazione del database prevede l'uso dei seguenti comandi:

```sql
CREATE TABLE employees (data XML);
CREATE TABLE departments (data XML);
```

Queste tabelle permetteranno di memorizzare i dati XML relativi ai dipendenti e ai dipartimenti dell'azienda.

#### Inserire dati nelle tabelle XML

Per inserire dati nelle tabelle appena create, utilizziamo la funzione _XMLPARSE_ all'interno di una normale clausola _INSERT_, passando una stringa che rappresenta il documento XML da inserire. È possibile scegliere se mantenere o meno gli spazi bianchi.

```sql
INSERT INTO departments(data) 
VALUES (
    XMLPARSE(
        DOCUMENT CAST (
            '<depts>
                <dept deptno="10" dname="Administration"/>
                <dept deptno="20" dname="Sales"/>
                <dept deptno="30" dname="HR"/>
                <dept deptno="40" dname="IT"/>
                <dept deptno="50" dname="Transport"/>
            </depts>' 
        AS CLOB) PRESERVE WHITESPACE
    )
);
```

Questa query consente di inserire un documento XML nella colonna _data_ della tabella _departments_, garantendo la gestione dei dati XML all'interno del database DB2.

#### XQuery nella clausola SELECT

Ora che i dati sono stati inseriti nelle tabelle, possiamo iniziare a eseguire delle query. In questo primo esempio, vogliamo estrarre i nomi di tutti i dipartimenti e inserirli all'interno di elementi XML . Per fare ciò, utilizziamo la funzione _XMLQUERY_, che ci permette di integrare una query XQuery all'interno di un'espressione SQL.

```sql
SELECT XMLQUERY(
    'for $d in $list//dept 
     return <deptName>{ $d/@dname }</deptName>'
    PASSING dtable.data AS "list"
) 
FROM departments dtable;
```

La clausola _PASSING_ serve per specificare su quale frammento XML stiamo lavorando. In questo caso, passiamo il contenuto della tabella _departments_ come _list_, creando così la variabile `$list` che può essere utilizzata all'interno della query per fare riferimento al frammento XML precedentemente inserito nella tabella.

---

Ora rendiamo la query più complessa: vogliamo estrarre i nomi e gli stipendi di tutti i dipendenti con uno stipendio superiore a 50.000. Inoltre, desideriamo che i risultati siano inseriti all'interno di elementi e ordinati in base allo stipendio.

```sql
SELECT XMLQUERY(
    'for $e in $list//emp 
     where $e/@salary > 50000 
     order by $e/@salary 
     return <empSalary>{$e/@ename}{ $e/@salary }</empSalary>'
    PASSING etable.data AS "list"
) 
FROM employees etable;
```

Questa query cerca tutti gli elementi _emp_ all'interno del frammento XML, seleziona quelli con un attributo _salary_ superiore a 50.000, li ordina in base al valore dello stipendio e restituisce il risultato in un elemento . La clausola _PASSING_ assegna il contenuto della tabella _employees_ alla variabile `$list`, che viene poi utilizzata nella query per riferirsi ai dati XML precedentemente inseriti.

----

Ora vogliamo estrarre per ogni dipendente il suo nome, il suo stipendio e lo stipendio medio del dipartimento in cui lavora. Per farlo, utilizziamo la clausola _let_ per calcolare la media degli stipendi dei dipendenti appartenenti allo stesso dipartimento.

```sql
SELECT XMLQUERY(
    'for $e in $list//emp 
     let $avgsal := avg($list//emp[@deptno = $e/@deptno]/@salary) 
     return <averages>{$e/@ename}{$e/@salary}{$avgsal}</averages>'
    PASSING etable.data AS "list"
) 
FROM employees etable;
```

In questa query, il ciclo _for_ itera su tutti gli elementi _emp_ presenti nel frammento XML. La clausola _let_ viene eseguita ad ogni iterazione, calcolando per ogni _emp_ il valore medio dello stipendio (_@salary_) di tutti i dipendenti appartenenti allo stesso dipartimento (_@deptno_). Il risultato viene restituito all'interno di un elemento , che include il nome del dipendente, il suo stipendio e lo stipendio medio del dipartimento.

La clausola _PASSING_ assegna il contenuto della tabella _employees_ alla variabile `$list`, permettendo di accedere ai dati XML presenti nel database.

#### Operatori condizionali

In questo esempio, vogliamo creare un elemento che rimanga vuoto se il dipendente _John_ guadagna più di _Smith_, oppure che contenga lo stipendio di _Smith_ in caso contrario.

```sql
SELECT XMLQUERY(
    'let $john := $list//emp[@ename="John"]
     let $smith := $list//emp[@ename="Smith"]
     return
       if ($john/@salary > $smith/@salary)
       then <salaries/>
       else <salaries>{$smith/@salary}</salaries>'
    PASSING etable.data AS "list"
) 
FROM employees etable;
```

In questa query, la clausola _let_ assegna rispettivamente a `$john` e `$smith` i nodi XML corrispondenti ai dipendenti con nome _John_ e _Smith_. Successivamente, viene utilizzato un'espressione _if-then-else_ per confrontare i loro stipendi: se lo stipendio di _John_ è maggiore di quello di _Smith_, viene restituito un elemento vuoto; altrimenti, l'elemento conterrà lo stipendio di _Smith_.

La clausola _PASSING_ permette di accedere ai dati XML presenti nella tabella _employees_, assegnandoli alla variabile `$list` per essere utilizzati nella query.

#### Operatori insiemistici

In questo esempio, vogliamo estrarre i nomi di tutti i dipendenti che lavorano nel dipartimento con _@deptno = 30_ oppure di quelli che guadagnano meno di 100.000.

```sql
SELECT XMLQUERY(
    'let $emps30 := $list//emp[@deptno = 30]
     let $empspoor := $list//emp[@salary < 100000]
     for $e in ($emps30 union $empspoor)
     return <empName>{$e/@ename}</empName>'
    PASSING etable.data AS "list"
) 
FROM employees etable;
```

In questa query, le clausole _let_ definiscono due insiemi: `$emps30`, che rappresenta tutti i dipendenti appartenenti al dipartimento 30, e `$empspoor`, che include quelli con uno stipendio inferiore a 100.000. Poiché le assegnazioni _let_ sono al di fuori del ciclo _for_, vengono calcolate una sola volta per ottimizzare l'esecuzione.

Successivamente, l'operatore _union_ combina questi due insiemi, e la clausola _for_ itera su tutti gli elementi risultanti, restituendo per ciascuno un elemento `<empName>` contenente il nome del dipendente.

La clausola _PASSING_ assegna il contenuto della tabella _employees_ alla variabile `$list`, permettendo di accedere ai dati XML presenti nel database.

#### Quantificatori

In questo esempio, vogliamo estrarre i nomi e gli stipendi di tutti i dipendenti, ma solo se esiste almeno un dipendente con uno stipendio superiore a 100.000.

```sql
SELECT XMLQUERY(
    'if (some $emp in $list//emp satisfies ($emp/@salary > 100000)) 
     then 
       <results> 
         {for $e in $list//emp 
          return <emp>{$e/@ename}{$e/@salary}</emp>}
       </results> 
     else 
       <results/>'
    PASSING etable.data AS "list"
) 
FROM employees etable;
```

In questa query, l'espressione `some $emp in $list//emp satisfies ($emp/@salary > 100000)` verifica se esiste almeno un dipendente con uno stipendio superiore a 100.000.

- Se la condizione è soddisfatta (_then_), la query itera su tutti i dipendenti e restituisce un elemento `<results>`, contenente una lista di `<emp>` con nome e stipendio di ciascun dipendente.
- Se la condizione non è soddisfatta (_else_), la query restituisce semplicemente `<results/>`, un elemento vuoto.

La clausola _PASSING_ permette di accedere ai dati XML presenti nella tabella _employees_, assegnandoli alla variabile `$list`.

#### Join

In questo esempio, vogliamo selezionare i nomi di tutti i dipendenti che lavorano nel dipartimento denominato _"Purchasing"_. Per eseguire il _join_ tra le tabelle _employees_ e _departments_, utilizziamo la clausola _PASSING_ per passare entrambi i dataset XML.

```sql
SELECT XMLQUERY(
    'let $purchasingdep := $dlist//dept[@dname = "Purchasing"]
     for $e in $elist//emp 
     where $e/@deptno = $purchasingdep/@deptno
     return <empName>{$e/@ename}</empName>'
    PASSING etable.data AS "elist", dtable.data AS "dlist"
) 
FROM employees etable, departments dtable;
```

In questa query:

- La clausola _let_ assegna a `$purchasingdep` l'elemento _dept_ il cui nome (_@dname_) è _"Purchasing"_.
- Il ciclo _for_ itera su tutti gli elementi _emp_ nella lista di dipendenti `$elist`.
- La clausola _where_ filtra i dipendenti confrontando il loro _deptno_ con quello del dipartimento _Purchasing_.
- La query restituisce per ogni dipendente selezionato un elemento `<empName>` contenente il nome del dipendente.
- La clausola _PASSING_ assegna i dati XML delle tabelle _employees_ e _departments_ alle variabili `$elist` e `$dlist`, permettendo di eseguire l'operazione di join.

---

In questo esempio, vogliamo selezionare per ciascun dipartimento il suo nome e la somma degli stipendi di tutti i dipendenti che vi lavorano. Per farlo, utilizziamo la clausola _let_ per calcolare la somma degli stipendi e la clausola _PASSING_ per eseguire il join tra le tabelle _employees_ e _departments_.

```sql
SELECT XMLQUERY(
    'for $d in $dlist//dept 
     let $sumsalary := sum($elist//emp[@deptno = $d/@deptno]/@salary) 
     return <deptCost>{$d/@dname} {$sumsalary}</deptCost>'
    PASSING etable.data AS "elist", dtable.data AS "dlist"
) 
FROM employees etable, departments dtable;
```

In questa query:

- Il ciclo _for_ scorre tutti gli elementi _dept_ presenti in `$dlist` (la lista dei dipartimenti).
- La clausola _let_ assegna alla variabile `$sumsalary` la somma degli stipendi di tutti gli elementi _emp_ che hanno un _deptno_ corrispondente a quello del dipartimento corrente.
- Il risultato è restituito all'interno di un elemento `<deptCost>`, che contiene il nome del dipartimento e la somma totale degli stipendi dei suoi dipendenti.
- La clausola _PASSING_ permette di passare entrambi i dataset XML (_employees_ e _departments_) alle variabili `$elist` e `$dlist`, consentendo il join tra i dati.

In quest'ultimo esempio di _XQuery_ in _SELECT_, vogliamo selezionare per ciascun dipartimento il numero dei dipendenti e il loro stipendio medio. I risultati devono essere ordinati in base al costo totale del dipartimento, calcolato come la somma degli stipendi, e devono includere solo i dipartimenti con più di un dipendente.

La query utilizza un ciclo _for_ per iterare su tutti i dipartimenti contenuti in `$dlist`. All'interno della clausola _let_, viene creata la variabile `$emps`, che rappresenta l'insieme di tutti i dipendenti il cui attributo `deptno` corrisponde a quello del dipartimento attuale. La clausola _where_ filtra i dipartimenti per includere solo quelli con più di un dipendente. I risultati vengono poi ordinati in ordine decrescente sulla base della somma degli stipendi di tutti i dipendenti appartenenti al dipartimento.

Il risultato viene restituito in un elemento , che contiene il nome del dipartimento, il numero di dipendenti (calcolato con `count($emps)`) e lo stipendio medio (calcolato con `avg($emps/@salary)`).

```sql
SELECT XMLQUERY(
    'for $d in $dlist//dept 
     let $emps := $elist//emp[@deptno = $d/@deptno] 
     where count($emps) > 1 
     order by sum($emps/@salary) descending 
     return 
       <big-dept> 
         {$d/@dname} 
         <headcount>{count($emps)}</headcount> 
         <avgsal>{avg($emps/@salary)}</avgsal> 
       </big-dept>'
    PASSING etable.data AS "elist", dtable.data AS "dlist"
) 
FROM employees etable, departments dtable;
```

La clausola _PASSING_ permette di passare i dataset XML delle tabelle _employees_ e _departments_ alle variabili `$elist` e `$dlist`, consentendo di eseguire il join tra i dati.

## XQuery e Oracle BD

Oracle DB offre un supporto completo a XQuery, in modo molto simile a DB2. Come si vedrà negli esempi, la maggior parte delle funzioni sono le stesse. Oracle XML DB è stato progettato con particolare attenzione alla coesistenza tra XQuery e SQL.

Anche se Oracle DB implementa tutte le principali funzionalità di XQuery, alcune caratteristiche dello standard non sono supportate. Non è possibile specificare la codifica utilizzata all'interno di un'espressione XQuery, poiché la funzione di version encoding non è disponibile. L'uso della funzionalità xml:id genera un errore. Il tipo di dato xs:duration non è supportato, ma è possibile utilizzare xs:yearMonthDuration o xs:DayTimeDuration come alternative.

Lo standard XQuery prevede che alcune funzionalità siano opzionali per una determinata implementazione. In Oracle XML DB non sono supportate la funzionalità di validazione dello schema e la funzionalità dei moduli, entrambe considerate opzionali nello standard.

Oracle DB offre un supporto completo alle funzioni e agli operatori inclusi in XPath 2.0, comprese le operazioni tra insiemi e quantificatori già viste per DB2. Tuttavia, ci sono alcune eccezioni. Non è possibile utilizzare le funzioni standard per la definizione delle espressioni regolari, in quanto è necessario ricorrere a quelle integrate nel DBMS. Le funzioni fn:id e fn:idref non sono supportate, così come la funzione fn:collection quando viene utilizzata senza argomenti.

#### Creazione di una tabella XML

In Oracle DB, così come in DB2, è possibile inserire colonne di tipo XML all'interno di tabelle relazionali utilizzando la parola chiave _XMLType_. Inoltre, è possibile creare tabelle interamente di tipo XML.

Ad esempio, per creare una tabella relazionale con una colonna XML, si può utilizzare il comando:  
`CREATE TABLE departments (id NUMBER(4), data XMLType);`

Se invece si vuole creare una tabella interamente di tipo XML, il comando sarà:  
`CREATE TABLE employees OF XMLType;`

Nei prossimi esempi, si assume che entrambe le tabelle _employees_ e _departments_ siano di tipo XML.

L'**XMLType** è un costrutto astratto che può essere implementato dal DBMS in due modi diversi. La prima opzione consiste nell'archiviare il dato all'interno di un **LOB (Large OBject)**, trattandolo come una semplice stringa. La seconda opzione è l'uso di un **Structured Storage**, in cui il DBMS crea automaticamente tabelle e viste che seguono lo schema XML del documento, suddividendo il contenuto nei singoli nodi in modo conforme al modello DOM (_Document Object Model_).

La scelta del metodo di archiviazione non influisce sui metodi con cui l'utente gestisce gli **XMLType**, ma ha un impatto sulle prestazioni delle query. Non esiste un metodo di archiviazione universalmente superiore: per ottenere le migliori performance è necessario valutare caso per caso.

#### Inserire dati nelle tabelle XML

Per inserire dati all'interno di una tabella o di una colonna di tipo XML, si utilizza la funzione **XMLType** all'interno di un comando **INSERT**, passando il frammento XML che si desidera inserire.

```sql
INSERT INTO departments VALUES (
    XMLType('
        <depts>
            <dept deptno="10" dname="Administration"/>
            <dept deptno="20" dname="Marketing"/>
            <dept deptno="30" dname="Purchasing"/>
            <dept deptno="40" dname="Publishing"/>
            <dept deptno="50" dname="Transport"/>
        </depts>'
    )
);
```

L'uso della funzione **XMLType** garantisce che il frammento XML venga memorizzato in formato XML valido all'interno della colonna della tabella.

Di seguito viene mostrata una query XQuery già eseguita in DB2, con differenze minime nell'implementazione su Oracle DB. L'obiettivo è estrarre il nome e lo stipendio di tutti i dipendenti con uno stipendio superiore a 50.000, ordinandoli dal meno pagato al più pagato.

```sql
SELECT XMLQUERY(
    'for $e in //emp 
     where $e/@salary > 50000 
     order by $e/@salary 
     return <empSalary>{ $e/@ename }{ $e/@salary }</empSalary>'
    passing etable.object_value 
    returning content
) 
FROM employees etable;
```

Rispetto a DB2, le differenze principali riguardano la **clausola passing**, che in Oracle DB fa riferimento all'oggetto XML, e l'aggiunta della **clausola returning content**, necessaria per restituire il risultato nel formato corretto. Tuttavia, il sistema di query rimane sostanzialmente lo stesso.

#### Join

Di seguito viene mostrata una query XQuery che esegue un **join** tra due tabelle XML in Oracle DB. La sintassi è molto simile a quella utilizzata in DB2. L'obiettivo è estrarre tutti i dipendenti che lavorano nel dipartimento denominato _"Purchasing"_.

```sql
SELECT XMLQUERY(
    'for $e in $elist//emp 
     let $d := $dlist//dept[@dname = "Purchasing"] 
     where $e/@deptno = $d/@deptno 
     return $e'
    passing etable.object_value as "elist",
            dtable.object_value as "dlist"
    returning content
) 
FROM employees etable, departments dtable;
```

In questa query:

- La variabile **$e** scorre tutti gli elementi `<emp>` presenti nella tabella _employees_.
- La variabile **$d** viene inizializzata con i dipartimenti che hanno il valore dell'attributo `dname` uguale a `"Purchasing"`.
- La condizione `where $e/@deptno = $d/@deptno` garantisce che vengano selezionati solo i dipendenti appartenenti al dipartimento desiderato.
- La **clausola passing** associa le tabelle _employees_ e _departments_ alle variabili XML `$elist` e `$dlist`.
- L'opzione **returning content** assicura che il risultato venga restituito in formato XML.

Anche in questo caso, la sintassi e la logica della query rimangono quasi identiche a quelle di DB2.

#### Lavorare direttamente su documenti XML

Se non si desidera inserire i dati nelle tabelle, è possibile utilizzare la funzione **doc()** per eseguire query direttamente sui file XML. Questo approccio consente di interrogare documenti XML senza la necessità di caricarli in un database.

Di seguito viene mostrato lo stesso esempio di query visto in precedenza, applicato però direttamente al file **employees.xml** anziché a una tabella.

```sql
SELECT XMLQUERY(
    'for $e in doc("employees.xml")//emp 
     where $e/@salary > 50000 
     order by $e/@salary 
     return <empSalary>{ $e/@ename }{ $e/@salary }</empSalary>'
    returning content
) AS result 
FROM DUAL;
```

In questa query:

- La funzione **doc("employees.xml")** carica direttamente il documento XML _employees.xml_.
- La query seleziona tutti gli elementi `<emp>` con uno stipendio superiore a **50.000**, ordinandoli in ordine crescente.
- L'output è formato da elementi `<empSalary>` contenenti il nome e lo stipendio di ciascun dipendente che soddisfa la condizione.
- L'opzione **returning content** assicura che il risultato venga restituito come XML.
- La tabella **DUAL** è una tabella speciale presente di default in Oracle. Viene utilizzata in questo caso per soddisfare la necessità della clausola **FROM**, obbligatoria nelle query SQL anche quando i dati provengono da altre fonti, come la funzione **doc()**.

Questo metodo consente di lavorare direttamente con file XML senza doverli necessariamente memorizzare in tabelle del database.

## XQuery e SQL Server

Microsoft SQL Server supporta solo un sottoinsieme delle funzionalità di XQuery, poiché si basa sulla bozza di lavoro del 2004 dello standard. Ora analizzeremo quali funzionalità non sono state implementate in questo DBMS.

#### Sequenze e path expressions

In SQL Server, le sequenze presentano alcune limitazioni specifiche. Devono essere omogenee, quindi possono essere composte esclusivamente da nodi o valori atomici. Inoltre, non è supportata la costruzione esplicita delle sequenze e non è possibile utilizzare gli operatori union, intersect ed except per combinare sequenze formate da nodi.

Per quanto riguarda le espressioni di percorso, il supporto è solo parziale. È possibile utilizzare gli assi child, descendant, parent, attribute, self e descendant-or-self. Tuttavia, sono supportati solo alcuni tipi di nodi, tra cui comment(), node(), processing-instruction() e text().

#### Espressioni FLWOR

Le espressioni FLWOR sono completamente supportate in SQL Server. Tuttavia, è importante sottolineare che, in SQL Server 2019, le espressioni assegnate a una variabile tramite la clausola LET vengono inserite nella query ogni volta che la variabile viene menzionata. Di conseguenza, l'espressione non viene eseguita una sola volta, ma viene ricalcolata ogni volta che la variabile viene richiamata.

Tra le altre funzionalità supportate da SQL Server, vi sono i costrutti condizionali if-then-else, gli operatori di confronto e gli operatori logici, sebbene sia possibile utilizzare solo and e or, mentre la funzione not non è disponibile. Sono supportati tutti gli operatori ad eccezione di idiv, così come tutte le funzioni di aggregazione. Inoltre, sono gestite anche le espressioni con quantificatori esistenziali e universali, come some/satisfies ed every/satisfies.

#### Creazione di una tabella XML

Per la creazione di una tabella XML, così come avviene in DB2, è necessario prima definire una tabella in grado di gestire i dati XML. Per farlo, basta inserire una colonna di tipo XML all'interno della tabella.

```sql
CREATE TABLE employees(
    col1 INT PRIMARY KEY,
    data XML
);

CREATE TABLE departments(
    col1 INT PRIMARY KEY,
    data XML
);
```

Questa struttura consente di memorizzare dati XML all'interno della colonna dedicata, permettendo operazioni specifiche per questo tipo di formato.

#### Inserire dati nelle tabelle XML

Per inserire dati XML all'interno della tabella appena creata, è sufficiente fornire una stringa contenente il frammento XML nell'operazione di `INSERT`.

Ecco un esempio corretto di inserimento di dati nella tabella `departments` utilizzando un valore XML ben formato:

```sql
INSERT INTO departments VALUES 
(1, 
'<depts>
    <dept deptno="10" dname="Administration"/>
    <dept deptno="20" dname="Marketing"/>
    <dept deptno="30" dname="Purchasing"/>
    <dept deptno="40" dname="Publishing"/>
    <dept deptno="50" dname="Transport"/>
</depts>');
```

In questa istruzione, la colonna di tipo `XML` riceve una stringa ben strutturata che rappresenta l'elenco dei dipartimenti. È importante assicurarsi che l'XML sia ben formato, evitando errori di sintassi o tag mal chiusi.

#### Differenze tra SQL SERVER e BD2

Le differenze tra SQL Server e DB2 nell'esecuzione di query XQuery sono minime, principalmente legate al modo in cui i dati XML vengono gestiti all'interno delle tabelle.

Di seguito viene mostrato un esempio di XQuery utilizzata in SQL Server per estrarre il nome e lo stipendio dei dipendenti che guadagnano più di 50.000, ordinati per stipendio:

```sql
SELECT data.query('
    for $e in //emp
    where $e/@salary > 50000
    order by $e/@salary
    return <employee>{ $e/@ename }{ $e/@salary }</employee>
') AS result
FROM employees;
```


## XQuery e Oracle Berkeley 

Oracle Berkeley non è un vero e proprio DBMS, ma piuttosto un insieme di librerie che possono essere utilizzate all'interno dei linguaggi di programmazione più comuni per gestire database XML in modo semplice. A differenza dei database relazionali tradizionali, Oracle Berkeley non offre alcun supporto per le basi di dati relazionali. Tuttavia, è possibile operare anche tramite un'interfaccia a riga di comando, che consente di eseguire direttamente i comandi, come verrà illustrato negli esempi successivi.

L'elemento più fondamentale in Oracle Berkeley è il _container_, che può essere approssimativamente paragonato alle tabelle di un DBMS relazionale. Dopo aver creato un container, è possibile inserire documenti XML al suo interno. Per recuperare frammenti XML, si possono eseguire query XQuery direttamente sul container. Inoltre, è possibile utilizzare XML Schema per imporre vincoli sui documenti inseriti e migliorare l'integrità dei dati. Per ottimizzare le prestazioni, è anche possibile creare indici specifici.

#### Creazione di un container

Per creare un _container_ in Oracle Berkeley, è possibile scegliere tra due modalità di memorizzazione dei dati. La prima modalità, _by document_, conserva i documenti esattamente nel formato in cui sono stati forniti al sistema. La seconda modalità, _by nodes_, scompone i documenti nei singoli nodi che li compongono, memorizzandoli separatamente.

La memorizzazione _by nodes_ offre vantaggi significativi, tra cui la possibilità di modificare il documento in futuro e migliori prestazioni nelle operazioni di ricerca ed elaborazione.

Ecco un esempio di creazione di un _container_ utilizzando la console di Oracle Berkeley:

```shell
dbxml> createContainer example.dbxml
```

Con questo comando, viene creato un _container_ denominato `example.dbxml`, pronto per contenere documenti XML.

## Inserire un documento

Per inserire documenti all'interno del _container_ corrente in Oracle Berkeley, si utilizza l'operazione:

```shell
putDocument <namePrefix> <string> [f|s|q]
```

Il terzo parametro specifica il tipo di inserimento:

- Utilizzando `"f"`, la stringa fornita rappresenta il percorso del file XML da inserire.
- Utilizzando `"s"`, la stringa fornita è direttamente un frammento XML da memorizzare.

Esempi di inserimento tramite console:

```shell
dbxml> putDocument example.dbxml book1.xml '<book><title>Title1</title><author>Author1</author><pages>100</pages></book>' s
```

In questo caso, il documento XML viene inserito direttamente come stringa.

```shell
dbxml> putDocument example.dbxml book1.xml 'Document.xml' f
```

Qui, invece, il file `Document.xml` viene caricato nel _container_ `example.dbxml` partendo dal percorso fornito.

## Query

